<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="yuan" href="https://jyuanhust.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="yuan" href="https://jyuanhust.github.io/atom.xml"><link rel="alternate" type="application/json" title="yuan" href="https://jyuanhust.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="C++"><link rel="canonical" href="https://jyuanhust.github.io/2022/07/22/language/C++/C-%E6%95%99%E7%A8%8B/"><title>C++教程 - 编程语言 | Mi Manchi = yuan = Whatever is worth doing at all is worth doing well</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C++教程</h1><div class="meta"><span class="item" title="创建时间：2022-07-22 22:21:58"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-07-22T22:21:58+08:00">2022-07-22</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>37k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>34 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Mi Manchi</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://gitee.com/zkz0/image/raw/master/img/img(59).webp"></li><li class="item" data-background-image="https://gitee.com/zkz0/image/raw/master/img/img(45).webp"></li><li class="item" data-background-image="https://gitee.com/zkz0/image/raw/master/img/img(16).webp"></li><li class="item" data-background-image="https://gitee.com/zkz0/image/raw/master/img/img(49).webp"></li><li class="item" data-background-image="https://gitee.com/zkz0/image/raw/master/img/img(82).webp"></li><li class="item" data-background-image="https://gitee.com/zkz0/image/raw/master/img/img(30).webp"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="item" rel="index" title="分类于 编程语言"><span itemprop="name">编程语言</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jyuanhust.github.io/2022/07/22/language/C++/C-%E6%95%99%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="yuan"><meta itemprop="description" content="Whatever is worth doing at all is worth doing well, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="yuan"></span><div class="body md" itemprop="articleBody"><p>第 2 章 类型、常量及变量</p><h2 id="单词"><a class="anchor" href="#单词">#</a> 单词</h2><p>c++ 使用 ASCII 字符集（主要包括英文字母、阿拉伯数字、运算符以及各种标点符号，还有不可显示的字符）中的字符来构造 “单词”，常量、变量名、函数名、参数名、类型名、运算符、关键字等都是 “单词”。关键字也被称为保留字，程序员不能用它来定义变量名、函数名或者参数名。</p><p>空格符和制表符都是分隔符，都能用于分隔两个标识符，例如用于分隔类型名与变量名。运算符和标点符号也能起分隔符的作用。例如 <code>a+b</code> 中的 <code>+</code> 。标点符号（如逗号）也可以用作运算符，用逗号构成的表达式如 <code>3, 6, 9</code> 称为逗号表达式，其结果为最后一个逗号后的操作数的值。</p><p>ASCII 字符集对小写字母、大写字母和阿拉伯数字均采用连续编码的方式， <code>A</code> 为 65， <code>a</code> 为 97， <code>0</code> 为 48。将字符 <code>2</code> 转化为数字的方式：用字符’2‘的 ASCII 值减去字符’0‘的 ASCII 值，即 <code>'2'-'0'</code> 。</p><p>建议使用 wchar_t 和 wcout 实现国际文字（包括中文）的输出。</p><h2 id="预定义类型及值域和常量"><a class="anchor" href="#预定义类型及值域和常量">#</a> 预定义类型及值域和常量</h2><p>预定义类型是指 c++ 预先定义的保留类型，这些类型通常是简单类型（如 bool、char 等）。简单类型的数值在计算时，一般遵循从有符号数向无符号数转换、从字节小的类型向字节大的类型转换的原则。</p><p>auto、register、static 和 extern 说明变量的存储位置特性；const、constexpr、volatile 和 mutable 等说明变量的存储可变特性。mutable 用于说明实例变量（即示例数据成员）的存储可变特性。</p><p>存储位置特性用于说明变量的存储位置。如 static 定义的静态变量和 extern 说明的全局变量编译后再数据段内分配内存。作为程序一部分的数据段会随程序存放于磁盘文件中，数据段内没有初始化的变量在磁盘对应位置上的值通常为 0.auto 说明的局部变量或函数参数在栈段（Stack Segment，SS）分配内存，函数内未使用 static 定义的局部变量默认为 auto 变量。编译程序会自动地分配和回收栈段分配的内存。</p><p>register 用于在函数内定义寄存器变量。如果数量有限的寄存器被分配完，或者寄存器变量出现取地址操作，register 变量就被编译成 auto 变量。另一方面，如果有多于的寄存器没被使用，即使局部变量被定义为用 auto 来分配栈内存，也有可能被编译优化成使用 register 存储。因此 register 和 auto 是可以相互转化的。</p><p>对于布尔类型，false 为 0，true 为 1. 非零的数值转化为 true，为零的数值转化为 false。</p><p>字符常量值在内存中存储的是该字符的 ASCII 值</p><p><code>'\113'</code> 和 <code>'\x48'</code> 分别为 <code>'K'</code> 的八进制（3 位，不足则在最高位补 0）和十六进制（2 为）的 ASCII 表示， <code>\</code> 为转义字符，不区分其中十六进制数的大小写。注意，u'a' 是 char16_t 类型大小为 2 个字节的常量，而 U'a' 是 char32_t 类型大小为 4 个字节的常量。</p><p>字符串类型可以解释为字符数组类型，同时，字符数组的首地址也可当做字符指针使用，其类型为 const char *，即指向只读字符的指针。当字符串中出现双引号时，使用转移字符。</p><p>整数除了可以用十进制表示外还可以用八进制或十六进制表示，其中八进制以 0 开始，十六进制以 0x 或 0X 开始。如果要表示无符号数，则可以在整数后面加 u 或者 U。</p><p>有符号长整型常量以 l 或 L 结束；无符号长整型常量以 UL、Ul、ul 或 uL 结束，其中 U、u 同 L、l 的位置可以互换，建议书写使均用大写字母。0LL 是 8 个字节的 long long 类型有符号超长整数。</p><p>浮点常量默认当做 double 类型处理，例如 5.、.32、0.34E-10 等。如果浮点常量以小写字母 l 或大写字母 L 结束，则其类型被认为是 long double 类型。浮点常量也可用 E 和 e 的科学计数法表示，e 后面的整数表示 10 的整数次方。</p><p>浮点常量的书写格式：</p><ol><li>小数点两边至少一边有数</li><li>e 或 E 的两边必须都有数，且 e 或 E 的右边必须是整数</li></ol><p>注：非扩展 ASCII 表中的字符常量采用 1 个字节的内存存储；而扩展的字符集常量则默认按 4 个字节存储，即默认字符类型为 char32_t</p><h2 id="一些关键字"><a class="anchor" href="#一些关键字">#</a> 一些关键字</h2><h3 id="constexpr"><a class="anchor" href="#constexpr">#</a> constexpr</h3><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639139817207.png" alt></p><h4 id="常量表达式"><a class="anchor" href="#常量表达式">#</a> 常量表达式</h4><p>所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。</p><p>实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 1)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> url<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 正确</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 2)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> url<span class="token punctuation">[</span><span class="token number">6</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 正确</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 3)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> url<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 错误，length 是变量</span></pre></td></tr></table></figure><p>上述代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。</p><blockquote><p>常量表达式的应用场景还有很多，比如匿名枚举、switch-case 结构中的 case 表达式等，</p></blockquote><p>C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。值得一提的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p>如何才能判定一个表达式是否为常量表达式，进而获得在编译阶段即可执行的 “特权” 呢？除了人为判定外，C++11 标准还提供有 constexpr 关键字。</p><p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p><blockquote><p>注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p></blockquote><h4 id="constexpr修饰普通变量"><a class="anchor" href="#constexpr修饰普通变量">#</a> constexpr 修饰普通变量</h4><p>定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。<br>使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式（等号右边是包含变量的时候会报错）。举个例子：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">int</span> url<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> url<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token comment">// 程序执行结果为 2</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足 “num 是 const 常量且使用常量表达式为其初始化” 这 2 个条件，由此编译器会认定 num 是一个常量表达式。</p><blockquote><p>注意，const 和 constexpr 并不相同，关于它们的区别，我们会在下一节做详细讲解。</p></blockquote><p>当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639137961763.png" alt></p><h4 id="constexpr修饰函数"><a class="anchor" href="#constexpr修饰函数">#</a> constexpr 修饰函数</h4><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为 “常量表达式函数”。</p><p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p><h5 id="该函数必须有返回值即函数的返回值类型不能是-void"><a class="anchor" href="#该函数必须有返回值即函数的返回值类型不能是-void">#</a> 该函数必须有返回值，即函数的返回值类型不能是 void。</h5><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 函数体</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p><h5 id="函数在使用之前必须有对应的定义语句"><a class="anchor" href="#函数在使用之前必须有对应的定义语句">#</a> 函数在使用之前，必须有对应的定义语句</h5><p>我们知道，函数的使用分为 “声明” 和 “定义” 两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。<br>在调用前的声明和定义可以同时存在。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">fill</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num <span class="token operator">+</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    </pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">10</span> <span class="token operator">+</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">display</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">//int arr [display (x)];  // 错误</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token function">fill</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num <span class="token operator">+</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>程序员告诉编译器尽管信心十足地把 func 当做是编译期就能计算出值的程式，但却欺骗了它，程序员最终并没有传递一个常量字面值到该函数。没有被编译器中止编译并报错的原因在于编译器并没有 100% 相信程序员，当其检测到 func 的参数是一个常量字面值的时候，编译器才会去对其做优化，否则，依然会将计算任务留给运行时。</p><p>我的理解：如果在编译时无法判断这个是否可以在编译时就可以计算，就不会</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639138703973.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639138663849.png" alt></p><h5 id="return-返回的表达式必须是常量表达式"><a class="anchor" href="#return-返回的表达式必须是常量表达式">#</a> return 返回的表达式必须是常量表达式</h5><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> num <span class="token operator">+</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 调用常量表达式函数</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>该程序无法通过编译，编译器报 “display (3) 的结果不是常量” 的异常。</p><p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">//return num + x;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 调用常量表达式函数</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token function">display</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639139545931.png" alt></p><h4 id="const和constexpr的比较"><a class="anchor" href="#const和constexpr的比较">#</a> const 和 constexpr 的比较</h4><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639140114629.png" alt><br>const 并不能代表 “常量”，它仅仅是对变量的一个修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过堆栈溢出等方式修改）。而这个变量的值，可以在运行时也可以在编译时指定。</p><p>constexpr 可以用来修饰变量、函数、构造函数。一旦以上任何元素被 constexpr 修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”。</p><p>对于 f2 () ，胆小的编译器并没有足够的胆量去做编译期优化，哪怕函数体就一句 return 字面值；<br>编译期大胆地将 func () 做了优化，在编译期就确定了 func 计算出的值 10 而无需等到运行时再去计算。</p><p>这就是 constexpr 的第一个作用：给编译器足够的信心在编译期去做被 constexpr 修饰的表达式的优化。</p><h2 id="23-变量及其类型解析"><a class="anchor" href="#23-变量及其类型解析">#</a> 2.3 变量及其类型解析</h2><p>变量是标识符标记的内存单元的数据载体。在说明简单类型的变量时，只需要知名变量的类型和名称；在定义简单类型的变量时，还需要给出变量的初始值。</p><p>变量说明的一般形式为 <code>extern 存储可变特性 类型名 变量名;</code> ，其中定义存储可变特性的关键字有 const、constexpr、volatile 和 mutable，而 mutable 只能用于在 extern 不出现时说明实例数据成员。</p><p>const 和 constexpr 的变量为只读变量，当前进程只能取其值，不能对其进行修改，即赋新值；volatile 的变量会 “自主” 发生变化。说明或定义变量时可以使用 const volatile 或者 constexpr volatile，表示当前进程没有修改变量的值，但可能另一个进程在修改其值，从而引起该变量的值 “自主” 发生变化。</p><p>同一个变量可以被重复说明多次，因此通常将变量说明和函数说明放在.h 文件中。不可以对变量进行多次定义。</p><p>变量定义的一般形式为 <code>存储位置特性 存储可变特性 类型名 变量名=初始值;</code> ，在函数体内定义局部变量时，存储位置特性为四选一，若不选择在默认使用栈存储即 auto；在函数外部定义变量时，只能在 static 和 extern 中二选一，若不选择则默认使用 extern，即定义在数据段中存储的全局变量。</p><p>定义变量时必须指定或默认有初始值，变量定义在整个程序范围内只能进行一次。若一个程序由多个.cpp 文件构成，则总共只能在一个.cpp 文件中定义一次。提倡只在某一个.cpp 文件中定义变量，在其他.cpp 文件或.h 文件中使用 extern 说明该变量。</p><p>可以使用运算符 <code>&amp;</code> 声明和定义有址引用。当 &amp; 出现在声明或定义中时，表示声明或定义变量、函数参数或者函数返回值为有址引用；当 &amp; 出现在表达式中的变量前时，表示获取该变量的地址。有址引用变量在定义的同时必须初始化，即必须指明被有址引用变量所引用的实体。一旦指明被有址引用变量引用的实体，有址引用变量和被引用实体的关系就被固定，即有址引用变量以后就不能再引用其他的实体。</p><p>传统左值指的是 C 语言定义的能够出现在赋值号左边的变量或者表达式，传统右值指的是 C 语言定义的只能出现在赋值号右边的变量或者表达式。传统左值是分配了内存的、有地址的，或有址的。一个传统左值就是一个传统右值，反之则不一定成立。在传统右值中，有一部分右值是有址的，例如只读变量，而另一部分右值（如常量）则是无址的。有址引用变量可以说明为传统左值或传统右值。</p><p>逻辑上有址引用变量不分配内存，而是共享被引用变量的内存，使用取址运算会得到与被引用变量相同的地址。</p><p>当 C++ 程序被编译为低级语言程序（如汇编语言和机器指令程序）时，有址引用变量被编译为指针。</p><p>位段成员是有名无址的，它既可能是左值，也可能是右值。常量通常认为是不分配内存的，在汇编语言中，常量是汇编指令 “操作数” 的立即数，不会再数据段为其分配内存。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>w <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>针对上面的程序，编译程序的实现方法是：生成一个只读匿名变量，在读内存中为该变量分配内存，常量 7 用于初始化该匿名变量，然后 w 引用该有址匿名变量，并共享该匿名变量的内存。常量 7 是用过即死的立即数。</p><p>y++ 和 y-- 是传统右值</p><p>无址引用变量是指使用 &amp;&amp; 定义的引用无址右值的变量，包括传统左值无址引用变量和传统右值无址引用变量。</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639042176714.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639042356667.png" alt><br><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639042387848.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639042453869.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639042516653.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639043318751.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639044068223.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639044165504.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639046479835.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639046533549.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639046814572.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639046900033.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639047152625.png" alt><br><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639047173281.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639047318358.png" alt><br><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639047342542.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639047565809.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639047643158.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639047850828.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639047969988.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639048172540.png" alt></p><h1 id="第3章-语句-函数及程序设计"><a class="anchor" href="#第3章-语句-函数及程序设计">#</a> 第 3 章 语句、函数及程序设计</h1><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639048766877.png" alt><br>声明函数的时候，可以共用函数的返回和存储特性同时进行多个函数的声明</p><h2 id="32"><a class="anchor" href="#32">#</a> 3.2</h2><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639049065895.png" alt></p><h3 id="constexpr函数"><a class="anchor" href="#constexpr函数">#</a> constexpr 函数</h3><p>constexpr 函数指的是在编译的时候就能得到其返回值的函数，也就是说编译器将 constexpr 函数直接转换成其返回值，因此，constexpr 函数都是被隐式地定义为内联函数。使用 constexpr 关键字来修饰 constexpr 函数。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>此时，编译器会将 myFunc () 函数用其返回值 1 来代替，在编译时就可知 i 的值是 4。</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639049930228.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639049949044.png" alt></p><h3 id="33-作用域"><a class="anchor" href="#33-作用域">#</a> 3.3 作用域</h3><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639050260075.png" alt></p><h1 id="第4章-类"><a class="anchor" href="#第4章-类">#</a> 第 4 章 类</h1><h2 id="41-类的声明和定义"><a class="anchor" href="#41-类的声明和定义">#</a> 4.1 类的声明和定义</h2><p>类的属性用数据成员表示，类的方法用函数成员表示。</p><p>对象即类的示例，也就是某个类的值。对象可以是变量，也可以是常量。类是一种数据结构，而对象则代表一段内存，存储了数据结构的值。当产生一个对象时，必须调用构造函数初始化对象，为对象申请各种资源；当一个对象 “死亡” 时，则需要调用析构函数，释放对象占用的资源。</p><p>实例函数成员是指间接或直接通过对象即实例调用的函数成员，因此实例函数成员都有隐含参数 this。如果类没有自定义某些特殊的函数成员如析构函数、构造函数和赋值运算函数，则编译程序会为该类生成默认析构函数、构造函数、赋值运算函数。自动生成的构造函数参数表无显式参数，通常不会初始化数据成员，仅保证类的正常运作，如维护函数的多态性。</p><p>构造函数是与类同名的实例函数成员，用于对对象的数据成员进行初始化（申请各种资源），对象必须初始化且仅能初始化一次。数据成员如果为内存指针则分配内存，为文件指针则打开文件。</p><p>析构函数用于对数据成员申请的资源进行回收。析构函数与类同名且名前有 <code>~</code> 的实例函数成员。析构函数可以执行多次，但应避免。自定义和默认生成的析构函数的参数表都没有参数，只能有一个隐含参数 this。</p><p>构造函数和析构函数都不能定义返回类型，没有 return，一般为公开函数。</p><p>函数绑定是指为函数调用寻找入口地址并调用的过程。早期绑定是指在程序代码运行之前完成的绑定，通常由编译程序静态连接或者由操作系统动态连接完成。而在程序运行期间由程序自己根据调用对象的类型，寻找合适的多态函数入口地址并调用的过程称为晚期绑定。完成晚期绑定过程的代码由编译程序预先插入程序中，早期绑定不需要编译程序插入完成绑定过程的代码。</p><p>如果在类的外部定义函数成员，则必须在函数名前加上类名即作用域运算符 <code>::</code> 。</p><p>使用 <code>. -&gt; :: .* -&gt;*</code> 调用的函数成员都称为显式调用函数成员。除了构造函数和析构函数能被编译程序自动调用外，其他任何函数成员都只能被显式调用。构造函数只能被编译程序隐式或自动调用，析构函数还可以被程序员显式调用。</p><p>构造函数是唯一不能被显式调用的函数成员。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>STRING <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>上面的代码隐式调用 <code>STRING(&quot;abc&quot;)</code></p><p>对于未初始化的 class、struct 和 union 类型的变量，如果这些类没有基类和对象成员，也没有自定义构造函数、虚函数、纯虚函数，则可以对这样的类的变量以 <code>&#123;...&#125;</code> 列表的形式初始化；对于这些类型没有初始化的全局变量和静态变量，编译程序将其实例数据成员的值默认初始化为 0 或 nullptr。</p><p>析构函数既能被显式调用，又能被隐式或自动调用。当一个对象的生命期结束时，编译程序会自动调用该对象的析构函数。</p><p>如果程序在运行期间非正常退出，则析构函数可能没被自动调用。在通常情况下，应该使用 return 语句正常退出程序，或者使用异常处理机制处理异常。exit 和 abort 属于非正常退出，exit 退出时还会执行收工函数，而 abort 不会，两者都不析构当前函数已经构造的局部对象，abort 还不会执行全局对象的析构。</p><p>如果显式调用了析构函数，而隐式析构又照常进行，则同一对象会被多次，从而使系统资源反复释放。为了防止同一对象反复析构，析构后应设置已被析构的标志。虽然操作系统允许内存反复释放，但不允许文件和设备多次析构关闭。（在析构函数中判断内存是否已被释放）</p><p>对象在其声明期结束时自动析构，且对象自动析构的顺序和其创建顺序相反。常量对象（如有一条语句为 <code>STRING(&quot;constant&quot;);</code> ) 在构造之后立即析构，其生命期为该常量所在的数值表达式的计算期间，数值表达式一旦计算完成，常量对象就会立即析构；若数值表达式有多个常量对象，则按创建顺序的逆序进行析构。</p><p><mark>当没有为类自定义任何构造函数，如果该类自定义或继承了虚函数或纯虚函数、或自定义了只读或引用数据成员但没指定默认值，或者该类的对象成员或基类必须用实参调用构造函数初始化，则编译程序会为该类自动生成拷贝构造、移动构造及没有显式形参的构造函数。若该类的基类或者对象成员存在析构函数，或者该类继承或自定义了虚函数或纯虚函数，若该类没有自定义析构函数，则编译程序会自动生成析构函数。</mark></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639050916549.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639051052024.png" alt></p><h2 id="42-成员访问权限及突破方法"><a class="anchor" href="#42-成员访问权限及突破方法">#</a> 4.2 成员访问权限及突破方法</h2><p>private 声明的成员是私有的，仅同一类中的成员能够访问私有成员；protected 声明的成员是受保护的，其所在类及派生类的成员函数可以访问；public 声明的成员是公开的，任何成员或非成员函数都能访问。</p><p>对于由 class 定义的类，在刚进入 class 类体的内部时，成员的访问权限默认为 private；而 struct 和 union 的默认为 public。</p><p>不管什么访问权限的成员，都可被该类的友元访问。</p><p>如果两个类的结构完全相同，只是对应数据成员的某些访问权限不同，通过强制类型转换，便可改变对应成员的访问权限，从而可以访问原有类型所不允许访问的数据成员。</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639051286697.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1639051522563.png" alt></p><h2 id="43-内联-匿名类及位段"><a class="anchor" href="#43-内联-匿名类及位段">#</a> 4.3 内联、匿名类及位段</h2><p>不管是否出现 inline 内联关键字，在类体内定义函数体的任何函数都会自动称为内联函数。内联函数成员也可以在类体外定义，但必须用 inline 关键字显式地加以说明（类内的 inline 可省，类外的 inline 不可省）。</p><p>若内联函数成员使用了分支、循环、开关及函数调用等分支类型的语句，或在还未定义其函数体以前调用了该内联函数成员，或该函数成员被定义为虚函数或纯虚函数，则该内联函数成员的内联动作就会失败。内联失败不代表编译程序会报告语法错误，而是意味着该内联函数成员将被当做常规的函数成员调用。</p><p>匿名类没有类名，因此不可以定义构造函数和析构函数，函数成员也不可以在类体外定义。</p><p>有虚函数成员时无法定义有参构造函数，从而不能用 <code>&#123;...&#125;</code> 来初始化</p><p>无对象的匿名联合具有如下特点：</p><ul><li>必须定义存储位置特性 static</li><li>只能定义公开实例数据成员</li><li>其实例数据成员和联合本身的作用域相同（不能再定义同名变量）</li><li>所有实例数据成员共享内存空间</li></ul><p>对于函数外部无对象的匿名联合，其实例数据成员被编译成共享内存的模块静态变量；对于函数内部无对象的匿名联合，如果该联合前面出现了 static，则其实例数据成员被编译成共享内存的局部 static 变量，否则，为局部 auto 变量，若没有初始化，它们的值为栈上的随机值。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">CLERK</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">union</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 无对象的内部匿名 union 等价于 static union，有对象时不等价</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> wage<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>局部类是指在类体中或函数体中定义的类。因为 c++ 不支持在函数内嵌套定义函数，故局部类的函数成员只能在局部类中定义函数体。</p><p>class、struct 和 union 的实例数据成员都能定义位段，但位段成员的类型必须是字节数较少的数据类型，如 char、short、int、long、long long 等有符号或无符号类型，不能是浮点型、数组和类等类型。枚举也可。</p><h2 id="44-new和delete运算符"><a class="anchor" href="#44-new和delete运算符">#</a> 4.4 new 和 delete 运算符</h2><p>new 负责分配对象内存，在分配内存之后，调用构造函数构造对象；delete 负责释放内存，在释放内存之前，调用析构函数析构对象。</p><p>一般来说，如果一个 class 定义了构造函数和析构函数，并且在构造函数中使用 new 分配了内存，则在析构函数中应使用 delete 释放在构造函数中用 new 分配的内存。</p><p>下面为示例代码</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>ARRAY <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">//ARRAY 为定义的一个类，</span></pre></td></tr><tr><td data-num="2"></td><td><pre>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ARRAY</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 不能用 malloc，因为 ARRAY 有构造函数，在分配一个 ARRAY 对象的内存时初始化</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">delete</span> p<span class="token punctuation">;</span>  <span class="token comment">// 不能用 free，因为 ARRAY 有析构函数</span></pre></td></tr></table></figure><p>通过 new 产生的对象是有地址的</p><p>编译程序不会自动调用通过 new 产生的对象的析构函数，必须由程序员使用 delete 析构对象并释放对象所占用的内存。语句 <code>delete p</code> 将通过调用析构函数 <code>p-&gt;~ARRAY()</code> ，析构释放 p-&gt;a 的内存空间，然后调用 free (p) 释放对象占用的内存。</p><p>在用 new 为数组分配空间时，数组的第一维下标可以是动态的，即可以使用任意整型表达式；而数组的其他维必须是静态的，即必须使用整型常量表达式。如果数组元素的类型为类，且希望用 new 创建对象数组，则该类应该自定义无参构造函数；如果类没有自定义任何构造函数，则可使用编译程序生成的无参构造函数。使用 <code>delete []s</code> 析构数组中的每个对象，s 为数组名，不管数组多少维都使用这种形式析构。</p><p>体现对象思想的语句</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//int x = 3;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="45-隐含参数this"><a class="anchor" href="#45-隐含参数this">#</a> 4.5 隐含参数 this</h2><p>类有两种类型的成员：实例函数成员和静态函数成员。静态函数成员使用 static 说明，实例函数成员不能使用 static 说明；实例函数成员比静态函数成员多了隐含参数 this。隐含参数 this 是实例函数成员的第一个参数，其类型与实例函数成员参数表后的修饰符有关，一般为指向此类对象的 const 指针。</p><p>当一个对象调用一个实例函数成员时，对象地址作为被调函数的第一个实参，通过压栈将实参传递给该函数的隐含参数 this。构造函数和析构函数的隐含参数 this 的类型只能为 <code>C * const</code> ，而不能为 const C * const 或 volatile C * const，</p><p>this 的作用：</p><ul><li>使用 this 访问实例数据成员可区分与其同名的成员函数参数（也可以使用 <code>类名::</code> 来区分）</li><li>在使用对象调用该实例函数成员时，this 将会指向调用当前函数的对象</li><li>当函数需要返回一个对象时，或者返回针对调用对象的引用时，可以使用 <code>*this</code> 作为函数的返回值</li></ul><p>实例函数成员参数表后可以出现 const 或 volatile，它们用于修饰函数隐含参数 this 指向的对象。实例函数成员的参数表后出现 const，表示 this 所指向的对象是不能修改的只读对象，</p><h2 id="46-对象的构造与析构"><a class="anchor" href="#46-对象的构造与析构">#</a> 4.6 对象的构造与析构</h2><p>若一个类自定义了构造函数，则其对象必须用构造函数初始化。可以采用 <code>&#123;&#125;</code> 的形式初始化对象成员，也可在有构造函数时调用构造函数。对象数组的初始化必须调用无参构造函数。</p><p>当类含有只读和引用实例数据成员时，如果这些只读和引用实例数据成员没有默认值，则必须为初始化这些成员自定义构造函数。假定类 A 存在一个类型为 B 类的实例数据成员，且 B 类所有构造函数都存在没有默认值的参数，则类 A 必须自定义构造函数来调用类 B 的有参构造函数。</p><p>构造函数必须在其参数表及 <code>:</code> 的后面，调用其基类或虚基类的构造函数，初始化其只读和引用类型的变量，以及初始化类型为类的实例数据成员（简称对象成员）。构造函数参数表后的 <code>:</code> 和 <code>&#123;</code> 之间被称为该构造函数的初始化位置。在构造函数体内，也可以对数据成员赋值，此种赋值不等价于初始化。对于定义了默认值的实例数据成员，若它没有出现在构造函数的初始化位置，则编译程序会使用默认值对其初始化，否则该默认值被编译程序忽略。默认值可以是简单类型的值或者类的对象。</p><p>可写成员既可以出现在构造函数的初始化位置，也可以出现在构造函数的函数体内。</p><p>注意构造函数是不能被直接调用的，也不能取构造函数的入口地址，构造函数是不可被访问的。</p><h1 id="第5章-成员及成员指针"><a class="anchor" href="#第5章-成员及成员指针">#</a> 第 5 章 成员及成员指针</h1><h2 id="51-实例成员指针"><a class="anchor" href="#51-实例成员指针">#</a> 5.1 实例成员指针</h2><p>运算符 <code>.*</code> 和 <code>-&gt;*</code> 均为双目运算符，其运算的优先级均为第 14 级，结合时按自左向右的顺序进行，运算符 <code>.*</code> 的左操作数为类的对象，右操作数为指向该对象成员的指针；运算符 <code>-&gt;*</code> 的左操作数为对象指针，右操作数为指向该对象实例成员的指针。</p><p>实例成员指针是一种数据类型，包括实例数据成员指针和实例函数成员指针。在获取实例成员地址时，要注意实例成员的访问权限是否允许访问。普通变量，数据成员、函数参数、函数返回值都可以定义为成员指针类型。</p><p>在类中，未用 static 定义的数据成员和函数成员均为实例成员，必须通过对象才能访问这些成员。实例成员指针要和对象一起使用。</p><p>实例数据成员实际上是一个偏移量，是某个成员的内存地址与所属对象的首址之差。当实例成员指针指向某个实例数据成员时，不能移动该指针指向其他实例数据成员。因此，也不能将实例成员指针强制转换为其他类型或者进行反向操作。否则通过 “转换成整型 -&gt; 整型数值运算 -&gt; 从整型转回” 等操作，便可以间接实现实例成员指针的移动。</p><h2 id="52-const-volatile和mutable"><a class="anchor" href="#52-const-volatile和mutable">#</a> 5.2 const、volatile 和 mutable</h2><h2 id="53-静态数据成员"><a class="anchor" href="#53-静态数据成员">#</a> 5.3 静态数据成员</h2><p>静态成员包括静态数据成员和静态函数成员，它们有关访问权限的规定和实例成员一样。在类体内声明的静态数据成员用于描述类的总体信息，<strong>除了定义为只读类型并且在类体内以常量表达式初始化以外，静态数据成员都必须在类体外定义并且初始化</strong>。</p><p>即使没有产生任何对象，即对象的个数为 0，在类体外定义并分配内存的静态数据成员仍然存在，可见数据成员在物理上独立于对象分配内存。因此，在使用 sizeof 获得类或者对象的字节数时，不包括静态数据成员的字节数，但逻辑上静态数据成员的内存被所有对象所共享。</p><p>若一个对象修改了静态数据成员的值，则意味着所有对象关于该成员的值同时被修改。在定义一个类时，类体中的静态数据成员只是一个说明，它未被定义和初始化，除非它被定义为只读静态数据成员并给出了初始值。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token comment">// 声明静态数据成员</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> A<span class="token double-colon punctuation">::</span>a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>A x<span class="token punctuation">;</span></pre></td></tr></table></figure><p>静态数据成员的 3 种访问形式</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>A<span class="token double-colon punctuation">::</span>a<span class="token punctuation">;</span>  <span class="token comment">// 此种形式说明静态数据成员可以脱离对象而存在，提倡使用</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>x<span class="token punctuation">.</span>A<span class="token double-colon punctuation">::</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>x<span class="token punctuation">.</span>a<span class="token punctuation">;</span></pre></td></tr></table></figure><p>没有在类体外定义，所以编译出错了</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211105002647530.png" alt="./images-20211105002647530"></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211105002845493.png" alt="./images-20211105002845493"></p><p>一旦在里面赋值，就是定义了，这个时候不能在类体外再赋值定义。</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211105003136330.png" alt="./images-20211105003136330"></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211105003359015.png" alt="./images-20211105003359015"></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211105003512742.png" alt="./images-20211105003512742"></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211105003922962.png" alt="./images-20211105003922962"></p><p>作用域局限于类体内的类称为嵌套类，作用域局限于函数的类称为局部类。局部类不能定义静态数据成员，否则便会造成静态数据成员的生存矛盾。因为在函数内部定义局部类后，还可定义该类的局部自动变量，以及该类的局部静态变量，这两种变量如果都共享静态数据成员，该成员在函数返回后会产生生存矛盾。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">//static int d; // 错误，局部类不能定义静态数据成员</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    </pre></td></tr><tr><td data-num="8"></td><td><pre>    T a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">static</span> T s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>静态数据成员不能定义为位段类型，因为位段成员没有地址无法独立分配内存。</p><p>全局联合和嵌套联合定义的静态数据成员不共享内存。嵌套联合是类体内定义的联合，局部联合是函数体内定义的联合。局部联合中不能定义静态数据成员。联合的静态数据成员也不能定位为位段。</p><p>非只读静态数据成员在类体外定义初始化时，必须以全局作用域形式定义并初始化，不能用 static 定义该成员使其局限于当前代码文件。</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211102235237217.png" alt="./images-20211102235237217"></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211102235251422.png" alt="./images-20211102235251422"></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211102235530638.png" alt="./images-20211102235530638"></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211102235557374.png" alt="./images-20211102235557374"></p><p>以上代码说明了类中的 const 成员的赋值只是默认值，在构造时若没有赋值则采用该值，并不是一般的只读变量。</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211102235624468.png" alt="./images-20211102235624468"></p><p>使用 inline 定义的模块（静态）变量和只读静态数据成员，分别称为内联模块（静态）变量和内联静态数据成员。内联静态数据成员 r 的内存在逻辑上仍由所有对象共享；而内联模块静态变量同模块普通静态变量一样，只能在该变量所属的.cpp 代码文件内访问。</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211103062849770.png" alt="./images-20211103062849770"></p><p>在类中未用 static 定义的的类只能通过对象访问成员</p><h2 id="54-静态函数成员"><a class="anchor" href="#54-静态函数成员">#</a> 5.4 静态函数成员</h2><p>静态函数成员的访问权限和继承规则同实例函数成员一样。</p><p>静态函数成员没有隐含参数 this。由于无法访问 this 指向的实例数据成员，因此静态函数成员一般用来访问类的静态数据成员。</p><p>调用方式</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>类名<span class="token double-colon punctuation">::</span>静态函数成员<span class="token punctuation">;</span>  <span class="token comment">// 提倡</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>对象<span class="token punctuation">.</span>静态函数成员<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>对象<span class="token punctuation">.</span>类名<span class="token double-colon punctuation">::</span>静态函数成员<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token operator">*</span>静态函数成员指针<span class="token punctuation">;</span></pre></td></tr></table></figure><p>静态函数成员用来对静态数据成员进行操作。</p><h2 id="55-静态成员指针"><a class="anchor" href="#55-静态成员指针">#</a> 5.5 静态成员指针</h2><h1 id="第6章-继承与构造"><a class="anchor" href="#第6章-继承与构造">#</a> 第 6 章 继承与构造</h1><h2 id="61-单继承类"><a class="anchor" href="#61-单继承类">#</a> 6.1 单继承类</h2><p>在继承已有类型的数据成员和函数成员的基础上，定义新类只需定义原有类型没有的数据成员和函数成员。新类可以接受单个类提供的数据成员和函数成员，也可以接受多个类提供的数据成员和函数成员。这两种继承形式分别称为单继承和多继承。</p><p>接受成员的新类称为派生类，而提供成员的类称为基类。</p><p>继承方法有：</p><ul><li>在基类的基础上增加新的成员；</li><li>改变基类成员继承后的访问权限；</li><li>重新定义和基类成员同名的成员。</li></ul><p>联合既不能作为基类，也不能作为派生类。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 使用作用域或者 this 隐含参数修改成员</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">LOCATION</span><span class="token double-colon punctuation">::</span><span class="token function">moveto</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    LOCATION<span class="token double-colon punctuation">::</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 或者使用 this->x = x;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    LOCATION<span class="token double-colon punctuation">::</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 继承的写法</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//POINT2D 和 LOCATION 之间的 public 为基类的继承方式</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">POINT2D</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">LOCATION</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 新的成员</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">POINT2D</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">LOCATION</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token comment">// 需要先调用基类的构造函数</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 初始化派生类的数据成员</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    </pre></td></tr><tr><td data-num="13"></td><td><pre>    </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>POINT2D <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>p<span class="token punctuation">.</span><span class="token class-name">LOCATION</span><span class="token double-colon punctuation">::</span><span class="token function">moveto</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 访问基类函数</span></pre></td></tr><tr><td data-num="18"></td><td><pre>p<span class="token punctuation">.</span><span class="token function">moveto</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在 POINT2D 类的体外定义 <code>POINT2D::moveto</code> 函数时， <code>POINT2D::</code> 用于表示 moveto () 是属于 POINT2D 的函数成员，在 POINT2D::moveto () 的函数体中调用 moveto 时，可使用限定名 <code>LOCATION::moveto()</code> 调用基类的函数成员 moveto ()。</p><p>派生类也可以用 struct 声明，使用 class 和 struct 声明的不同之处在于：使用 class 声明时，基类的继承方式和进入派生类体后的访问权限默认为 private；使用 struct 声明时，基类的继承方式和进入派生类体后的访问权限默认为 public。</p><p>在派生类的初始化位置没有显式调用基类的构造函数时，会默认调用基类的无参构造函数，若基类没有无参构造函数，则报错。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">int</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 等价于 B ():A ()&#123;y=2&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="62-继承方式"><a class="anchor" href="#62-继承方式">#</a> 6.2 继承方式</h2><p>派生类的函数成员可以访问基类的保护成员和公开成员。除非定义为基类的友元函数，否则派生类的函数成员不能访问基类的私有成员。</p><p>假定访问权限和继承方式满足 private &lt; protected &lt; public，如果基类成员的访问权限高于基类的继承方式，则基类成员继承到派生类后，该成员的访问权限和继承方式一致；否则，该成员继续保持其在基类时的访问权限不变。</p><p>基类对象是派生类对象的一部分，基类对象先于派生类对象构造。在构造派生类对象时，先自动执行派生类的构造函数，并由其调用基类可被访问的构造函数，然后在派生类构造函数的初始化位置，按派生类定义其数据成员的顺序初始化派生类的数据成员，最后执行派生类自己的构造函数体。</p><p>注意：派生类一定会调用基类的构造函数，如果基类构造函数没有在派生类构造函数的初始化位置显式列出，则编译程序会自动调用基类的无参构造函数。如果基类定义的构造函数都是有参的，则编译程序将报告 “基类没有定义无参构造函数” 的错误；</p><p>基类和派生类都定义了函数 moveto ()，对 POINT2D 类的对象和函数成员来说，类 POINT2D 自动的 moveto () 函数被访问的优先级更高。因此，除非使用限定名 LOCATION::moveto () 调用 moveto，否则，在类 POINT2D 的函数成员 moveto 内调用的 moveto 一定是 POINT2D 自定义的 moveto 函数成员。</p><p>派生类对象不应再调用基类的函数成员，为了防止此种情况，可以将继承方式设置为 private。</p><p>为了修改继承到派生类中的 LOCATION::getx () 的访问权限，可以将 <code>LOCATION::getx</code> 放在派生类中希望的访问权限范围，或者使用 using LOCATION::getx 将 <code>LOCATION::getx</code> 放在派生类中希望的访问权限范围</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">POINT2D</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">LOCATION</span></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    LOCATION<span class="token double-colon punctuation">::</span>getx<span class="token punctuation">;</span> <span class="token comment">// 修改访问权限，还可被新定义的 getx 覆盖</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    LOCATION<span class="token double-colon punctuation">::</span>gety<span class="token punctuation">;</span> <span class="token comment">// 修改访问权限，还可被新定义的 gety 覆盖</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>需要指出的是，选用 private 作为继承方式并不是最好的选择。</p><p>在派生类中修改 getx () 的访问权限以后，通常不会在派生类中再定义参数表和基类 getx () 相同的 getx () 实例函数。此时，在没有派生关系的类或非成员函数中，通过 POINT2D 类对象调用 getx ()，就是调用 LOCATION::getx ()。而一旦派生类自定义了 getx () 实例函数，则派生类 POINT2D 对象将优先调用自定义的 getx () 实例函数，而基类的 getx () 只能通过限定名 LOCATION::getx () 去调用。</p><h2 id="63-成员访问"><a class="anchor" href="#63-成员访问">#</a> 6.3 成员访问</h2><p>如果希望访问基类作用范围更大的标识符，则可以用 <code>基类类名::标识符</code> 构成的限定名进行访问。</p><h2 id="64-构造与析构"><a class="anchor" href="#64-构造与析构">#</a> 6.4 构造与析构</h2><p>派生类构造函数的执行顺序是：</p><ol><li>若派生类存在虚基类，则先调用虚基类的构造函数</li><li>若存在直接基类，则接着调用直接基类的构造函数</li><li>然后按照派生类数据成员的声明顺序依次调用它们的构造函数或对其进行初始化（而不是初始化位置列出的顺序）</li><li>最后执行派生类构造函数的函数体</li></ol><p>析构函数的执行顺序相反</p><p>如果派生类定义了没有默认值的引用或只读实例数据成员，或者定义了必须调用有参构造函数初始化的的对象成员，或者继承或自定义虚函数或纯虚函数，或者其虚基类和基类必须用实参调用构造函数初始化，则派生类必须自定义构造函数，而不能依赖编译程序为其自动生成构造函数。</p><p>如果被 r 引用的对象是通过 new 生成的有址对象，则引用变量 r 必须用 <code>delete &amp;r</code> 析构该对象，否则该对象将因未释放内存而产生内存泄漏。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">*</span>s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>i <span class="token operator">=</span> x<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">delete</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">&amp;</span>p <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>new A(3)</code> 的执行过程为：</p><ol><li>先为对象 A (3) 分配一块内存，其大小为 sizeof (A)；</li><li>调用构造函数初始化 A (3)，构造函数为其成员 s 分配一块内存，该内存大小为 sizeof (int [3])。</li></ol><p>由此可见， <code>new A(3)</code> 导致总共分配了两块内存。</p><p>如果仅用 <code>p.~A()</code> 析构由 new 生成的对象 A (3)，则只释放了其成员 p.s 指向的大小为 sizeof (int [3]) 的内存块，没有释放 p 引用的对象 A (3) 所占用的内存，造成内存泄漏。</p><p>如果用 <code>delete &amp;p</code> 处理由 new 生成的对象，则会完成</p><ol><li>通过 p.~A () 调用析构函数析构由 new 生成的对象 A (3)，析构时释放 p.s 指向的内存；</li><li>使用 free (&amp;P) 释放 p 引用的对象 A (3) 占用的内存。</li></ol><h2 id="65-父类和子类"><a class="anchor" href="#65-父类和子类">#</a> 6.5 父类和子类</h2><p>如果派生类继承基类的方式为 public，则这样的派生类称为该基类的子类，而相应的基类则称为派生类的父类。C++ 允许父类指针直接指向子类对象，也允许父类引用变量直接引用子类对象。</p><p>编译时无法知道指向或引用的对象类型，指向或引用的对象类型只能在程序运行时确定，故编译程序只能根据变量的类型定义进行静态语法检查，即把父类指针变量指向的所有对象都当做父类对象。在通过父类指针变量访问对象的数据成员或函数成员时，如果父类定义的成员访问权限不允许当前访问，则编译程序就会报告访问权限超出限制等错误。父类引用变量也存在类似的静态语法检查。（父类和子类存在同名但参数表不同的函数，如果通过指向子类对象的父类指针以子类函数参数表的形式调用该函数，则编译出错）</p><p>若一个父类指针指向的是子类对象，如果父类和子类都定义了同名的函数且都可访问，由于编译程序只能做静态语法检查，故调用的同名函数是父类的实例函数成员。（定义为虚函数可解决问题）。同理，编译程序只能假定父类引用变量引用的都是父类对象。在通过引用变量访问对象的数据成员或函数成员时，不能突破父类对象为成员所规定的访问权限。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 父类引用变量可以直接引用子类对象，否则必须进行强制类型转换</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token keyword">int</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">int</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	A<span class="token operator">&amp;</span> p <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">new</span> C<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	A<span class="token operator">&amp;</span> q <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span> <span class="token comment">// 强制类型转换</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>没有继承关系的两个不同的类的两个对象的指针不能通过强制类型转换来赋值。</p><p>如果基类和派生类没有构成父子关系，且非成员函数 main () 不是派生类的友元函数，则 main () 定义的基类指针变量不能直接指向派生类对象，而必须通过强制类型转换才能指向派生类对象。同理，函数 main () 定义的基类引用变量也不能直接引用子类对象，而必须通过强制类型转换才能引用派生类对象。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">int</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">friend</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token keyword">int</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	A<span class="token operator">&amp;</span> p <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">new</span> C<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	A<span class="token operator">&amp;</span> q <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">new</span> B<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在作为派生类友元的函数 main () 中，基类和派生类默认满足父子类关系。这是因为基类对象继承到派生类后，可被视为匿名的具有某种访问权限的对象成员。而 main () 函数作为派生类的友元函数，可以访问派生类的所有成员，包括作为匿名对象的基类对象。这种对基类的无障碍访问，就像基类以公开方式继承到派生类，使基类可被派生类当做父类看待。</p><p>在派生类的函数成员中，基类和派生类默认满足父子关系，因为基类对象可被视作派生类的匿名成员，而派生类函数可以访问自己的所有成员，包括继承的作为匿名对象的基类对象。在派生类的函数成员中，这种对基类对象的无障碍访问，使基类可被当做派生类的父类看待。因此，基类指针或引用可以直接指向或引用派生类对象。</p><p><mark>注意：以上操作的关键是基类指针可以指向子类对象，并不能突破访问权限</mark></p><p>将上面代码中的类 B 的定义如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">int</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">friend</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>		A<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="66-派生类的内存布局"><a class="anchor" href="#66-派生类的内存布局">#</a> 6.6 派生类的内存布局</h2><p>静态数据成员在对象之外分配内存，函数成员也不是对象内存的一部分，函数成员编译后得到的二进制代码不占用对象内存。</p><p>基类对象是派生类对象内存的一部分，通常出现在派生类实例数据成员之前。因此，派生类对象所占用的内存通常由两部分构成：基类对象所占用的内存和派生类实例数据成员占用的内存，</p><p>实例数据成员在对象内部连续分配内存。</p><p>从子类的内存布局来看，其首部恰巧就是父类的内存布局，所以若把子类对象当做父类对象使用，不会导致父类对象所要求的内存布局与预期不一致的问题。</p><h1 id="第7章-可访问性"><a class="anchor" href="#第7章-可访问性">#</a> 第 7 章 可访问性</h1><h2 id="71-作用域"><a class="anchor" href="#71-作用域">#</a> 7.1 作用域</h2><h2 id="72-名字空间"><a class="anchor" href="#72-名字空间">#</a> 7.2 名字空间</h2><p>同一名字空间中的标识符必须唯一，不同名字空间中的标识符可以相同。当一个程序使用多个名字空间而出现成员同名时，可以用名字空间加作用域运算符限定各自的成员。</p><p>关键字 namespace 用于定义名字空间。名字空间必须在程序的全局作用域内定义，不能在函数及函数成员内定义，最外层名字空间的名称必须在文件作用域内唯一。</p><p>在当前.cpp 代码文件内可定义匿名名字空间，同一个.cpp 代码文件可分多次定义匿名名字空间，并且匿名名字空间定义后即默认被自动使用（即 using）。对于不同的 cpp 文件，若在它们的匿名名字空间内定义同名的全局变量、函数或类型成员，将不会引起二义性冲突。</p><h2 id="73-成员友元"><a class="anchor" href="#73-成员友元">#</a> 7.3 成员友元</h2><p>友元函数（简称 “友元”）不是声明该友元的类的函数成员，但是它能像类的函数成员一样访问该类的所有成员。友元分为普通友元和成员友元两种类型。普通友元是将普通函数定义为某个类的友元，成员友元是就将一个类的函数成员定义为另一个类的友元。</p><p>友元使用 friend 声明，友元只是声明它为类的朋友，而不是该类的函数成员，故不受该类的访问权限的限制，因此可随意访问在该类的 private、protected 和 public 下声明友元。如果一个类是另一个类的友元类，则前者的所有函数成员都能访问后者的任何成员，包括类型成员、数据成员和函数成员。</p><p>类的构造函数和析构函数也可以定义为另一个类的成员友元，由于构造函数和析构函数没有返回类型，故将他们定义为另一个类的友元时不需要指定它们的返回类型。对于其他具有返回类型的函数，在声明为某个类的友元时，必须说明其真实返回类型。</p><p>不能将尚未完整声明的类作为函数参数，因为此时该类的字节数或者类型大小尚不确定。但是，相互依赖的类可以使用类的引用或类的指针作为参数，因为引用式指针都会被编译为汇编语言的指针类型，而存储地址的指针变量所需要的字节数总是固定的。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">INTSET</span><span class="token punctuation">;</span> <span class="token comment">// 前向声明</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 没有前向声明，就无法在后面使用 INSET&amp; 或者 INSET * 等引用或指针类型</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">REALSET</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">float</span><span class="token operator">*</span> elems<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">int</span> card<span class="token punctuation">,</span> maxcard<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token comment">// 不可定义 REALSET (INTSET s)：因为 INTSET 字节数不定</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token function">REALSET</span><span class="token punctuation">(</span>INTSET<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token operator">~</span><span class="token function">REALSET</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">delete</span> elems<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">INTSET</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token keyword">int</span><span class="token operator">*</span> elems<span class="token punctuation">,</span> card<span class="token punctuation">,</span> maxcard<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token keyword">friend</span> <span class="token class-name">REALSET</span><span class="token double-colon punctuation">::</span><span class="token function">REALSET</span><span class="token punctuation">(</span>INTSET<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	<span class="token function">INTSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxcard<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	<span class="token operator">~</span><span class="token function">INTSET</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">delete</span> elems<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token class-name">REALSET</span><span class="token double-colon punctuation">::</span><span class="token function">REALSET</span><span class="token punctuation">(</span>INTSET <span class="token operator">&amp;</span>s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token comment">// 本函数声明为 INTSET 的友元，可直接访问 INTSET 的所有成员</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	elems <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span>maxcard <span class="token operator">=</span> s<span class="token punctuation">.</span>maxcard<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	card <span class="token operator">=</span> s<span class="token punctuation">.</span>card<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> card<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre>		elems<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span>elems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token class-name">INTSET</span><span class="token double-colon punctuation">::</span><span class="token function">INTSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>	elems <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>maxcard <span class="token operator">=</span> max<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>	card <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre>	INTSET <span class="token function">iset</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>	REALSET <span class="token function">rset</span><span class="token punctuation">(</span>iset<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>友元函数的声明可以出现在类的任何访问权限下，因为它不是该类的函数。</p><p>一个类的任何函数成员，如实例函数、静态函数、虚函数、构造函数以及析构函数等，都能成为另一个类的成员友元，而且能够同时成为多个类的成员友元。如果类 A 的所有函数成员都是类 B 的友元，则类 A 被称为类 B 的友元类，可在类 B 中以如下形式定义友元类 A： <code>friend A</code> ， <code>friend class A</code> ，或 <code>friend struct A</code> 。</p><h2 id="74-普通友元及其注意事项"><a class="anchor" href="#74-普通友元及其注意事项">#</a> 7.4 普通友元及其注意事项</h2><p>任何普通函数即非成员函数，包括非成员函数 main () 在内，都可以定义为类的普通友元。这种友元也称为非成员友元，声明其为友元的类称为宿主类。由于普通友元函数不是宿主的函数成员，故普通友元可定义于宿主类的任何访问权限下。一个普通函数可以定义为多个类的普通友元。</p><p>将非成员函数定义为类的友元时，可以在类中同时定义该友元的函数体。由于函数体是在类中定义的，因此该友元函数将自动称为 inline () 函数，且其作用域局限于当前代码文件（存储未知特性默认为 static）。但是，建议在类体外定义友元的函数体，因为此时类的所有成员都已定义完毕，作为该类的友元可以访问该类的所有成员。在类外定义友元时，如果希望友元具有局部作用域，可在函数前加上 inline 或 static。</p><p>由于全局 main () 函数的存储特性默认为 extern，因此不能在类体中定义全局 main () 函数的函数体。</p><p>普通友元可以访问宿主类的任何函数成员。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">friend</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	A a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span>x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>全局函数 main () 和析构函数不能重载，故不能定义多个 main () 和析构函数友元。在出现多个非成员重载函数时，未声明为友元的非成员函数只能访问类的公开成员，只有声明为友元的非成员函数才能访问类的所有成员。此外，同普通函数和函数成员一样，友元的参数也可以省略或指定默认值。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	B b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token operator">-></span>x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token comment">// 访问基类内存的方法</span></pre></td></tr><tr><td data-num="20"></td><td><pre> 	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>A<span class="token double-colon punctuation">::</span>x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>友元关系是不能传递的，即一个函数定义为基类的友元后，并不代表它是其派生类的友元。</p><p><mark>在非成员函数（如 main ()）中定义局部类时，该局部类可以说明某个函数为友元，但不能同时定义这个友元的函数体。但是，在全局类的嵌套类中定义友元函数时，可以同时定义该友元的函数体。</mark></p><h1 id="第8章-多态与虚函数"><a class="anchor" href="#第8章-多态与虚函数">#</a> 第 8 章 多态与虚函数</h1><p>多态是面向对象程序设计最显著的特点，在运行期间绑定虚函数到具体类的实函数，使对象在运行过程中做出同其类型相符的行为。多态需求是随着泛型的出现而出现的，当一个指针或者引用变量能够存储多种类型的数据时，就需要根据运行时变量关联的对象类型去调用相应的实函数。</p><h2 id="81-虚函数"><a class="anchor" href="#81-虚函数">#</a> 8.1 虚函数</h2><p>重载函数是一种静态多态函数，虚函数是一种动态多态函数。在编译时早期绑定完成重载函数的调用，在运行时晚期绑定完成虚函数的调用。虚函数到对象的函数成员的映射是通过存储在对象之中的一个指针完成的。</p><p>虚函数是用关键字 virtual 声明的实例函数成员。通常只需在基类中定义虚函数，派生类中原型相容的实例函数成员将自动成为虚函数。不管进行了多少级派生，虚函数的这一特性将一直延续传递。</p><p>实例函数成员的原型相容是指：</p><ol><li>该实例函数和基类的虚函数同名，并且除隐含参数的类型不同外，两个函数的所有显式参数类型都对应相同；</li><li>若基类虚函数的返回类型是基类指针 p（或引用 r），则派生类实例函数的返回类型必须是可向 p（或者 r）赋值的基类指针（或引用），或者是可向 p（或者 r）赋值的派生类指针（或引用），否则两个实例函数的返回类型必须相同。</li></ol><p>虚函数具有隐含参数 this，因此，虚函数不能定义为没有 this 的静态函数成员。构造函数虽有隐含参数 this，但要构造的对象类型明确且无须表现多态，构造函数不需要虚函数的多态特性，故 C++ 不允许将构造函数定义为虚函数或纯虚函数。</p><p>当父类和子类都定义了原型相容的虚函数时，如果父类指针（或引用）指向（或引用）的是子类对象，则通过父类指针或引用调用的是子类的函数成员；如果父类指针或引用指向的是父类对象，则通过父类指针或引用调用的是父类的函数成员。根据对象的真实类型不同而调用不同的实例函数，由此展现出的多种行为被称为虚函数的多态特性。</p><p>由于引用类型的变量被编译为指针，因此通过父类引用变量调用虚函数同指针调用一样表现多态特性。</p><p>虚函数是类自身的实例函数成员，而 friend 说明的函数不是当前类的成员，因此不能同时用 virtual 定义 friend 函数。此外虚函数不能定义为 constexpr 函数，不能接受类似 inline 的优化而丧失虚函数入口，虚函数入口用于填写虚函数入口地址表，该地址表的首址将成为对象存储的一个内部指针。</p><pre><code class="language-CPP">//下面的代码中，A和B不是父子类关系，但由于定义了虚函数，最终也可以准确调用相应的函数

#include &lt;iostream&gt;
using namespace std;
class A &#123;
public:
	virtual void f(); //声明为虚函数
	virtual ~A() &#123;&#125;;
&#125;;

//在类的外部定义虚函数的时候不需要再加virtual，这点和static静态变量类似
void A::f()
&#123;
	cout &lt;&lt; &quot;A&quot; &lt;&lt; endl;
&#125;

class B : A &#123;
public:
	virtual void f() &#123; cout &lt;&lt; &quot;B&quot;; &#125;;
&#125;;

int main()
&#123;
	cout &lt;&lt; &quot;hell&quot; &lt;&lt; endl;
	B b;
	A&amp; p = *(A*) &amp;b;  //不是父子类关系，需要强制类型转换才能赋值
	p.f();
    p.A::f();  //明确调用A::f()
	int x = 2;
&#125;


/*
以上代码若只去掉A中的virtual，则会打印出A


*/
</code></pre><p>当父类中有（纯）虚函数 f () 时，不允许在子类中定义函数名与 f 相同且参数表也相同仅返回类型不同的函数（理解为无法准确调用），但是如果函数名称相同，参数表不同，不管返回类型怎么样，都是可以的。</p><p>若 POINT2D* show () 和 CIRCLE * show () 为父类和子类的两个函数，则可以在父类的 show 前加 const、volatile 或 const volatile 都可以，但是不可以在子类的 show () 前加，这就导致原型不相容了。类似的，对于 POINT2D &amp; show () 和 POINT2D &amp;&amp; show () 也得出相似的结论。</p><p>不允许虚函数的返回类型不相容</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211105151608227.png" alt="./images-20211105151608227"></p><p>参数表不同就可以了，这种情况下无法通过父类指针调用子类的同名函数了</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211105152056899.png" alt="./images-20211105152056899"></p><p>虚函数的访问权限可以不同。</p><p>在 C++ 的同一个类中，不能定义参数个数及类型完全相同，仅返回类型不同的静态函数成员；也不能定义参数个数及类型完全相同、仅返回类型不同的实例函数成员，包括基类继承下来的 this 说明相同的实例函数成员。</p><p>设继承关系为：A-&gt;B-&gt;C</p><p>先检查 C 是否定义了相应的实例函数，若没有则继续往上检查，直到找到原型相容的实例函数然后调用。若在 A 中函数为公开的，而在 C 中为私有的，最终也会成功调用 C 中的该实例函数。因为函数调用在运行时进行，此时不再进行语法检查，因此被调用的实例函数的访问权限已无关紧要。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">virtual</span> A<span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>A<span class="token operator">*</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	B<span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B"</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hell"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	B b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>	A<span class="token operator">&amp;</span> p <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	p<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>C++ 可为类自动生成一些实例成员函数。例如，对类 A 来说，这些实例函数成员包括：</p><ul><li>参数表无参的构造函数，如 A ()</li><li>拷贝构造 A (const A&amp;) 和移动拷贝构造 A (A &amp;&amp;)</li><li>拷贝赋值 A &amp; operator=(const A&amp;) 和移动赋值 A &amp; operator=(A &amp;&amp;)</li><li>析构函数 A::~A ()</li></ul><p>一旦类 A 自定义了任何构造函数，就会禁止编译程序自动生成任何构造函数。同理，一旦类 A 自定义了任何赋值函数，就会进制编译程序自动生成任何赋值函数。</p><p>虚函数可以声明为 inline 函数，也可以重载、指定默认值或者省略参数。同实例函数成员一样，类体里定义了函数体的虚函数将自动成为内联函数。多个原型不同的虚函数也可以称为重载函数，重载时虚函数的参数个数或函数类型必须有所不同。</p><p>因为 friend 声明的函数不是宿主类的函数成员，所以它不能和声明实例函数成员的 virtual 一起使用，除非被声明的函数已经是另一个类的虚函数成员。</p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211105164825337.png" alt="./images-20211105164825337"></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211105165232612.png" alt="./images-20211105165232612"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">j</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">k</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token keyword">friend</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token keyword">friend</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">j</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">k</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token comment">//static virtual void m ();  // 有无 this 矛盾</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token comment">//virtual friend void n ();  // 是否成员函数矛盾</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token keyword">friend</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 正确，非成员函数 p 已定义为静态函数</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token keyword">friend</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">q</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 正确，自动生成静态非成员函数 q</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token comment">//friend static void r ();  // 编译时可以通过，但是一旦调用 r () 编译就通不过了，因为没有定义</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"helloworld"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="82-虚析构函数"><a class="anchor" href="#82-虚析构函数">#</a> 8.2 虚析构函数</h2><p>析构函数除了类型固定不变的隐含参数 this 外，它的显式参数表不能再定义其他任何类型的参数。因此，析构函数不可能有重载函数，也不可能有指定默认值的参数或者省略参数。</p><p>析构函数可以定义为虚函数。如果基类的析构函数定义为虚析构函数，则派生类的析构函数就会自动称为虚函数。</p><p>在形式如 <code>delete p;</code> 的语句中，p 可定义为指向父类对象的指针，为了使其能根据 p 指向的对象类型进行多态析构，最好将父类的析构函数定义为虚函数。 <code>delete &amp;q</code> 类似。</p><p>编译程序不能自动生成虚函数，需要自己定义。</p><p>如果为基类和派生类对象分配了内存，或者为派生类的对象成员分配的动态内存，则一定要将基类和派生类的析构函数定义为虚函数，否则便极有可能造成内存泄漏，甚至导致操作系统出现内存保护错误。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B"</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="83-类的引用"><a class="anchor" href="#83-类的引用">#</a> 8.3 类的引用</h2><p>常规对象常量的生命期局限于当前表达式，在表达式结束时就立刻进行析构。但无址引用变量引用的是对象常量，C++ 为无址引用引入了移动语义的概念，随着移动语义的引入，被无址引用的常量对象的析构将推迟到该无址引用变量的生命期结束。此时常量对象实际上被编译为存储于缓存的无址匿名只读变量。虽然无址引用变量不负责常量对象的析构，但被其引用的常量对象的析构确实与其生命期相关。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"构造:x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"析构：x="</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 还可 A&amp; m = *new A (1);</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	A<span class="token operator">&amp;</span> p <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token comment">//A&amp; t = A (1);  // 报错显示：非常量引用的初始值必须为左值</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token keyword">const</span> A<span class="token operator">&amp;</span> q <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传统右值有址引用，A (3) 延迟析构</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	A<span class="token operator">&amp;&amp;</span> r <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 传统左值无址引用，A (4) 延迟析构</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token keyword">const</span> A<span class="token operator">&amp;&amp;</span> s <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传统右值无址引用，A (5) 延迟析构</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>	r<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> r<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>	<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token comment">//A&amp;&amp; t = a; // 报错显示：无法将右值绑定到左值</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main return"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span>  <span class="token comment">// 退出 main 时按逆序自动析构所有已构造的对象</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="34"></td><td><pre>构造:x = 2</pre></td></tr><tr><td data-num="35"></td><td><pre>构造:x = 3</pre></td></tr><tr><td data-num="36"></td><td><pre>构造:x = 4</pre></td></tr><tr><td data-num="37"></td><td><pre>构造:x = 5</pre></td></tr><tr><td data-num="38"></td><td><pre>10</pre></td></tr><tr><td data-num="39"></td><td><pre>20</pre></td></tr><tr><td data-num="40"></td><td><pre>main return</pre></td></tr><tr><td data-num="41"></td><td><pre>析构：x=20</pre></td></tr><tr><td data-num="42"></td><td><pre>析构：x=10</pre></td></tr><tr><td data-num="43"></td><td><pre>析构：x=3</pre></td></tr><tr><td data-num="44"></td><td><pre>析构：x=2</pre></td></tr><tr><td data-num="45"></td><td><pre>*/</pre></td></tr></table></figure><p>有址引用变量的拷贝构造和赋值函数实现为深拷贝，而无址引用变量的移动拷贝构造和移动赋值函数实现为浅拷贝。无址引用变量和参数最好用常量对象初始化，否则移动拷贝构造和移动赋值可能引发内存保护错误。</p><p>在调用包含无址引用参数的函数时，需要将无址表达式传给该无址引用参数。如果将同类型的传统左值或者有址变量作为实参传递，则编译程序会给出已经错误警告或直接报错。即使能通过类型转换将前述传统左值作为实参转换类型传递，这种用法也是不提倡的，尤其是当参数为引用对象的无址引用类型时。因为当函数返回时会析构该无址引用参数引用的对象，与该左值共享内存的实参被析构了，但该左值的生命期不应在此结束，它可能被主调函数继续使用。</p><p>对形参不是引用类型而是一般对象类型来说，形参相当于局限于当前函数的局部变量。因此，这种形参对象的析构是在函数调用返回时完成的，而该形参对象的构造则是在调用时通过值传递完成的。如果定义了拷贝构造函数，将调用相应的拷贝函数完成。值参传递将实参对象数据的值相应地赋给形参对象的数据成员，而指针类型的数据成员则只浅拷贝复制指针的值赋给形参，而没有深拷贝复制指针所指向的存储单元内容的值。</p><p>因此，一般值参传递所进行的赋值又称为浅拷贝赋值，浅拷贝赋值会导致形参对象和实参对象指向共同的存储单元。由此造成的后果是：在被调用的函数返回时，形参析构会释放其指针成员指向的内存，该内存可能又被操作系统立即分配给其他程序，而当前程序并不知道该内存已分配给其他程序。此时，不知道内存已被析构的实参对象若通过指针成员访问内存，就会造成一个程序非法访问另一个程序的内存，这就是操作系统经常报告的内存保护错误或者一般性保护错误。</p><p>当非引用类型的形参对象包含指针数据成员时，必须进行深拷贝构造才能避免出现内存保护错误。将深拷贝构造函数的形参定义为类的传统右值有址引用，并另外定义一个传统左值无址引用形参的构造函数，这样就能隐藏编译程序自动生成的深拷贝构造和移动构造函数，从而在传递实参时优先调用自定义的深拷贝构造和移动构造函数。移动构造函数通常实现为浅拷贝构造函数，由于浅拷贝构造函数不分配内存，故不会因为内存分配失败而产生异常。</p><h2 id="84-抽象类"><a class="anchor" href="#84-抽象类">#</a> 8.4 抽象类</h2><p>纯虚函数是不必定义函数体的特殊虚函数。在定义虚函数时，说明其函数体 <code>=0</code> 表示定义的虚函数为纯虚函数。<strong>纯虚函数有隐含参数 this，故不能同时定义为静态函数</strong>。</p><p>含有纯虚函数的类称为抽象类，抽象类常常用作派生类的基类。</p><p>如果派生类继承了抽象类的纯虚函数，却未定义原型相容且带函数体的虚函数；或者派生类自定义了基类所没有的新纯虚函数，不管新纯虚函数是否在当前派生类定义了函数体，当前派生类都会自动称为抽象类。</p><p>在多级派生中，如果到某个派生类为止，所有的基类纯虚函数都在派生类中定义了函数体，并且该派生类没有自定义新的纯虚函数，则该派生类就会称为非抽象类（或者称为具体类）。<strong>只有非抽象类才能产生对象</strong>。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 定义 A 为抽象类</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 在类 A 中定义了 f1 () 的函数体，A 仍然是抽象类</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A::f1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A::f2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 覆盖 A::f2 () 的函数体，但未覆盖 A::f1 ()，B 仍为抽象类</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B::f2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">&#123;</span> <span class="token comment">//A::f1 () 和 A::f2 () 均被覆盖定义，C 为非抽象类</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"C::f1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"helloworld"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre>	C a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>抽象类不能定义或产生任何对象（没有可被引用或指向的对象），包括用 new 创建对象、定义对象数组以及定义对象参数或函数返回值。但是抽象类可作为父类引用和指针，引用或指向具体子类对象。</p><p>内存管理函数 malloc () 可以为抽象类对象分配空间，但不会调用抽象类的构造函数来初始化该对象，因此内存管理函数 malloc () 不能完整地初始化抽象类对象（对象中的虚函数入口地址表指针未被初始化）。只有成功完整地初始化了某个类的对象，才能通过抽象类指针或引用调用到这个类的虚函数。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A::f"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B::f"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"C::f"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	A<span class="token operator">&amp;</span> p <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">new</span> B<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>	p<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>	p<span class="token punctuation">.</span><span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"==========="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>	A<span class="token operator">&amp;</span> q <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">new</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>	q<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>	q<span class="token punctuation">.</span><span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="85-虚函数友元与晚期绑定"><a class="anchor" href="#85-虚函数友元与晚期绑定">#</a> 8.5 虚函数友元与晚期绑定</h2><p>纯虚函数和虚函数都是类的实例函数成员，都能定义为另一个类的成员友元。由于纯虚函数一般不会定义函数体，此时纯虚函数就不应该定义为某个类的成员友元，成员友元应当是定义了函数体的函数。</p><p>友元关系不能传递或者继承。如果类 A 的函数成员 f () 定义为类 B 的友元，那么 f () 就可以访问类 B 的所有成员，包括数据成员、函数成员及类型成员。但是，f () 并不能访问从类 B 派生的类 C 的所有成员，除非 A 的函数成员 f () 也被定义为类 C 的成员友元。</p><p>假定基类 B 及其派生类 D 都定义了虚函数，基类 B 和派生类 D 将分别产生虚函数地址表 TB 和 TD。在构造派生类 D 的对象 d 时，首先将 d 作为一个基类对象构造，故将 TB 的首址存放到 d 的起始单元，此时 B::B () 调用的虚函数将和 TB 中的虚函数绑定；然后一旦基类对象的构造函数 B::B () 执行完毕，在执行派生类的构造函数 D:😄() 之前，会将 TD 的首址存放到 d 的起始单元，此后 D:😄() 调用的虚函数就会和 TD 中的虚函数绑定。</p><p>同理，在析构派生类 D 的对象 d 时，一旦析构函数～D:😄() 的函数体执行完毕，就立即将 TB 的首址存放到 d 的起始单元，接着将 d 作为基类对象执行基类 B 的析构函数 <code>~B::B()</code> ，此后， <code>~B::B()</code> 调用的虚函数就会和 TB 中的虚函数绑定。这样，对象 d 就会根据其类型来调用正确的虚函数，从而表现出恰当的多态特性。</p><h2 id="86-有虚函数时的内存布局"><a class="anchor" href="#86-有虚函数时的内存布局">#</a> 8.6 有虚函数时的内存布局</h2><p>单继承派生类对象的内存由基类和派生类的实例数据成员构成。当基类或派生类定义了虚函数或者纯虚函数时，派生类对象的内存还包括虚函数入口地址表首址所占用的存储单元，存储单元通常是包含虚函数的基类对象的初始单元。</p><p>如果基类定义了虚函数或者纯虚函数，则派生类对象将共享基类对象的起始单元，用于存放虚函数入口地址表首址。派生类的构造函数和析构函数会选择合适的时机，在共享的存储单元中更新基类和派生类的虚函数入口地址表首址。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 纯虚函数的函数体仍然是可以正常调用的</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token keyword">static</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token keyword">int</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211105230616235.png" alt="./images-20211105230616235"></p><p>如果基类没有定义虚函数，而单继承派生类定义了虚函数，则单继承派生类的内存由 3 个部分组成：第一部分为基类内存，第二部分为派生类虚函数入口地址表首址，第三部分为该派生类新定义的实例数据成员。</p><h1 id="第9章-多继承与虚基类"><a class="anchor" href="#第9章-多继承与虚基类">#</a> 第 9 章 多继承与虚基类</h1><h2 id="91-多继承类"><a class="anchor" href="#91-多继承类">#</a> 9.1 多继承类</h2><p>当需要定义多继承派生类的对象时，常常通过对象成员的聚合实现多继承。对象聚合在多数情况下能够满足需要，但当对象成员和基类的类型相同，或者在逻辑上和基类对象存在共享的内存时，就可能对同一物理对象重复初始化。</p><p>多继承派生类可以定义任意数目的基类，但是不得定义名称相同的直接基类。当派生类有多个基类时，多个基类成员继承到派生类后可能同名，基类与派生类成员之间也可能同名。在出现成员同名时，除了可以根据作用域大小确定访问的优先级外，还可用作用域运算符限定要访问的类的成员。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">A</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token keyword">int</span> a<span class="token punctuation">;</span>  <span class="token comment">// 未定义构造函数 A::A ()，可用 &#123;&#125; 初始化</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token keyword">int</span> c<span class="token punctuation">;</span>  <span class="token comment">// 类 C 继承 A 和 B 的两个成员 a</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token keyword">int</span> <span class="token function">setc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token keyword">constexpr</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> A<span class="token punctuation">&#123;</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> B<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//A &#123;2&#125; 使 c.A::a=2，B &#123;&#125; 使 c.B::a=0</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">int</span> <span class="token class-name">C</span><span class="token double-colon punctuation">::</span><span class="token function">setc</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	C<span class="token double-colon punctuation">::</span>c <span class="token operator">=</span> c<span class="token punctuation">;</span>  <span class="token comment">// 使用作用域运算符限定访问数据成员 C::c</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	<span class="token keyword">return</span> c<span class="token punctuation">;</span>  <span class="token comment">// 返回的是参数的值，其作用域更小，访问优先级更高</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	A a<span class="token punctuation">;</span>  <span class="token comment">//a.a 为随机值</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	A b<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//b.a=0，如果 &#123;&#125; 中为空，则所有元素初始化为 0</span></pre></td></tr><tr><td data-num="31"></td><td><pre>	B<span class="token operator">*</span> c <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span> <span class="token comment">//c->a 为随机值</span></pre></td></tr><tr><td data-num="32"></td><td><pre>	B<span class="token operator">*</span> d <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//d->a=0 。等价于 new B ()</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>	C g<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>	<span class="token comment">//int j = g.a;  // 出现二义性访问</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	<span class="token keyword">int</span> j <span class="token operator">=</span> g<span class="token punctuation">.</span>B<span class="token double-colon punctuation">::</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>	<span class="token keyword">delete</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>	<span class="token keyword">delete</span> d<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="第10章"><a class="anchor" href="#第10章">#</a> 第 10 章</h1><h2 id="101-异常处理"><a class="anchor" href="#101-异常处理">#</a> 10.1 异常处理</h2><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638575823505.png" alt></p><p>抛出来的需要是一个完整定义的对象或者指向完整对象的指针，因此异常类型要定义在抛出异常语句的前面</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">INDEX</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">int</span> index<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token function">INDEX</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">index</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">int</span> <span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> index<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ARR</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token keyword">int</span> size<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token function">ARR</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token keyword">int</span> <span class="token function">getIn</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token operator">~</span><span class="token function">ARR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token class-name">ARR</span><span class="token double-colon punctuation">::</span><span class="token function">ARR</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>		ARR<span class="token double-colon punctuation">::</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>			arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	<span class="token keyword">else</span></pre></td></tr><tr><td data-num="30"></td><td><pre>		<span class="token keyword">throw</span> <span class="token function">INDEX</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token keyword">int</span> <span class="token class-name">ARR</span><span class="token double-colon punctuation">::</span><span class="token function">getIn</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> size<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>		<span class="token keyword">throw</span> <span class="token function">INDEX</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>	<span class="token keyword">else</span></pre></td></tr><tr><td data-num="38"></td><td><pre>		<span class="token keyword">return</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token class-name">ARR</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">ARR</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>		<span class="token keyword">delete</span> arr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>		arr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>		size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="49"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="50"></td><td><pre></pre></td></tr><tr><td data-num="51"></td><td><pre></pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span>ARR<span class="token operator">&amp;</span> arr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="53"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>	<span class="token keyword">int</span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>	<span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>		<span class="token comment">//int m = arr.getIn (2);  // 如果在这里面定义 m，那么出来这个语句块之后就无法使用 m 了</span></pre></td></tr><tr><td data-num="57"></td><td><pre>		m <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">getIn</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="59"></td><td><pre></pre></td></tr><tr><td data-num="60"></td><td><pre>	<span class="token comment">//int flag = 0; //try 和 catch 语句之间不能再有其他语句</span></pre></td></tr><tr><td data-num="61"></td><td><pre></pre></td></tr><tr><td data-num="62"></td><td><pre>	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> INDEX<span class="token operator">&amp;</span> ind<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="63"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="64"></td><td><pre>		<span class="token keyword">switch</span> <span class="token punctuation">(</span>ind<span class="token punctuation">.</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="65"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="66"></td><td><pre>		<span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="67"></td><td><pre>			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"内存分配失败"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="68"></td><td><pre>			<span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="69"></td><td><pre>		<span class="token keyword">default</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="70"></td><td><pre>			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"下标"</span> <span class="token operator">&lt;&lt;</span> ind<span class="token punctuation">.</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"越界"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>		<span class="token keyword">throw</span><span class="token punctuation">;</span>  <span class="token comment">// 传播异常</span></pre></td></tr><tr><td data-num="73"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="75"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="76"></td><td><pre>		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"异常被上面捕获，这里不会执行"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="78"></td><td><pre>	<span class="token keyword">return</span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="80"></td><td><pre></pre></td></tr><tr><td data-num="81"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="82"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>	ARR <span class="token function">arr</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="84"></td><td><pre>	<span class="token comment">// 一定要使用 try 语句，try 和 catch 是配套使用的</span></pre></td></tr><tr><td data-num="85"></td><td><pre>	<span class="token keyword">int</span> m<span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="86"></td><td><pre>	<span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="87"></td><td><pre>		<span class="token comment">//int m = arr.getIn (2);  // 如果在这里面定义 m，那么出来这个语句块之后就无法使用 m 了</span></pre></td></tr><tr><td data-num="88"></td><td><pre>		m <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">getIn</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="89"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="90"></td><td><pre></pre></td></tr><tr><td data-num="91"></td><td><pre>	<span class="token comment">//int flag = 0; //try 和 catch 语句之间不能再有其他语句</span></pre></td></tr><tr><td data-num="92"></td><td><pre></pre></td></tr><tr><td data-num="93"></td><td><pre>	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> INDEX <span class="token operator">&amp;</span>ind<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="94"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="95"></td><td><pre>		flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="96"></td><td><pre>		<span class="token keyword">switch</span> <span class="token punctuation">(</span>ind<span class="token punctuation">.</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="97"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="98"></td><td><pre>		<span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="99"></td><td><pre>			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"内存分配失败"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="100"></td><td><pre>			<span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="101"></td><td><pre>		<span class="token keyword">default</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="102"></td><td><pre>			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"下标"</span> <span class="token operator">&lt;&lt;</span> ind<span class="token punctuation">.</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"越界"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="103"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="104"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="105"></td><td><pre></pre></td></tr><tr><td data-num="106"></td><td><pre>	</pre></td></tr><tr><td data-num="107"></td><td><pre>	<span class="token comment">// 在执行 catch 语句之后，下面的语句将继续执行</span></pre></td></tr><tr><td data-num="108"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="109"></td><td><pre>		m <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="110"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="111"></td><td><pre></pre></td></tr><tr><td data-num="112"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"----------------------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="113"></td><td><pre></pre></td></tr><tr><td data-num="114"></td><td><pre>	<span class="token comment">// 异常的传播用在函数的多级调用中，同级不能传播异常</span></pre></td></tr><tr><td data-num="115"></td><td><pre>	<span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="116"></td><td><pre>		<span class="token function">func</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="117"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="118"></td><td><pre>	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="119"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="120"></td><td><pre>		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"接受到传播的异常"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="121"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="122"></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="123"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;exception></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">EPISTLE</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">exception</span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token function">EPISTLE</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">exception</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Construct:"</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token operator">~</span><span class="token function">EPISTLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">noexcept</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Deconstruct:"</span> <span class="token operator">&lt;&lt;</span> exception<span class="token double-colon punctuation">::</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token keyword">return</span> exception<span class="token double-colon punctuation">::</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">void</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	EPISTLE <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">"I am in h()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token function">EPISTLE</span><span class="token punctuation">(</span><span class="token string">"I have throw an exception\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	EPISTLE <span class="token function">g</span><span class="token punctuation">(</span><span class="token string">"I am in g()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	<span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>	EPISTLE <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"I am in f()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	<span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>	<span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>		<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> EPISTLE<span class="token operator">*</span> m<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="45"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>		cout <span class="token operator">&lt;&lt;</span> m<span class="token operator">-></span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>		<span class="token keyword">delete</span> m<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="第11章-运算符重载"><a class="anchor" href="#第11章-运算符重载">#</a> 第 11 章 运算符重载</h1><p>C++ 默认提供赋值运算符重载，但这种浅拷贝赋值易造成内存泄漏。</p><h2 id="111-运算符概述"><a class="anchor" href="#111-运算符概述">#</a> 11.1 运算符概述</h2><p>运算符有时称为运算符函数，运算符的操作数相当于函数参数。</p><p>运算结果为传统左值的运算符称为传统左值运算符，这样的运算符构成的表达式可以出现在等号左边（必有一个传统左值变量代表其运算结果）。前置 ++、-- 以及赋值运算符 =、+=、*= 和 &amp;= 等均为传统左值运算符。某些单目运算符要求其操作数为传统左值，如前置和后置运算符 ++ 和 --；一些双目运算符要求第一个操作数为传统左值，如赋值运算符 =、 <code>*=</code> 、&amp;= 等。有些运算符仅要求其操作数为传统右值，如加、减、乘、除运算符等。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token operator">++</span>x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token operator">++</span> <span class="token operator">++</span>x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token operator">--</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">(</span>x <span class="token operator">+=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li><p><code>sizeof</code> <code>.</code> <code>.*</code> <code>::</code> <code>?:</code> 不可以重载</p></li><li><p><code>=</code> <code>-&gt;</code> <code>()</code> <code>[]</code> 只能重载为实例函数成员，不能重载为静态函数成员或非成员函数</p></li><li><p>new 和 delete 不能重载为实例函数成员，即可以重载为静态函数成员或非成员函数</p></li><li></li></ul><h1 id="第12章-类型解析-转换与推导"><a class="anchor" href="#第12章-类型解析-转换与推导">#</a> 第 12 章 类型解析、转换与推导</h1><h2 id="121-隐式与显式类型转换"><a class="anchor" href="#121-隐式与显式类型转换">#</a> 12.1 隐式与显式类型转换</h2><p>C++ 为简单类型提供了自动类型转换机制，即</p><h2 id="123-类型转换实例"><a class="anchor" href="#123-类型转换实例">#</a> 12.3 类型转换实例</h2><h2 id="124-自动类型推导"><a class="anchor" href="#124-自动类型推导">#</a> 12.4 自动类型推导</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;typeinfo></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span> <span class="token comment">//char</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">auto</span> e <span class="token operator">=</span> <span class="token string">"abce"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">//static g = 0;  // 必须明确说明类型，不能认为 g 的默认类型为 int</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// 推导返回类型为 int</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">inline</span> <span class="token keyword">auto</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">inline</span> <span class="token keyword">auto</span> <span class="token keyword">const</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> m <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 有 inline 时可以使用任意表达式初始化 m？更改编译器的版本可以编译通过</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638592452839.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638592792514.png" alt></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;typeinfo></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">auto</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">auto</span><span class="token operator">*</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//c 和 d 的类型相同</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">auto</span> e <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// 对 a 取地址也是正确的</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">auto</span> f <span class="token operator">=</span> printf<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token keyword">auto</span> m <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638609720909.png" alt></p><h2 id="125-lambda表达式"><a class="anchor" href="#125-lambda表达式">#</a> 12.5 Lambda 表达式</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;typeinfo></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token keyword">mutable</span><span class="token operator">-></span><span class="token keyword">int</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		x <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"jjj"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	f<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>	<span class="token comment">// 圆括号，形参列表，箭头和返回类型同时不出现</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	<span class="token keyword">auto</span> g <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>	<span class="token comment">// 有圆括号和形参列表，但是没有说明返回值，然而在函数体中有返回值，在下面的代码中依然正确返回了</span></pre></td></tr><tr><td data-num="32"></td><td><pre>	<span class="token keyword">auto</span> h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>		<span class="token keyword">int</span> m <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>		<span class="token keyword">return</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>	<span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"----------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>	m <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638613554330.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638612761270.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638612961798.png" alt></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;typeinfo></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">return</span> x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>g<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> f<span class="token punctuation">;</span>  <span class="token comment">// 利用函数名赋值给一个函数指针</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-></span><span class="token keyword">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 捕获列表为空，当准函数使用</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token keyword">auto</span> g <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-></span><span class="token keyword">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">-></span><span class="token keyword">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>	h <span class="token operator">=</span> f<span class="token punctuation">;</span>  <span class="token comment">// 由这两个赋值可以看出这三个 lambda 表达式当作准函数使用</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>	<span class="token keyword">auto</span> m <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">-></span><span class="token keyword">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">//m 是准对象</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>k<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token comment">//k = [x](int i) ->int &#123;return i; &#125;; // 准对象不能赋值给函数指针</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	<span class="token comment">//k = m;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>	<span class="token comment">//cout &lt;&lt; typeid([](int i)->int &#123;return i; &#125;).name() &lt;&lt; endl;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638613174567.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638614646936.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638614818892.png" alt></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;typeinfo></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">-></span><span class="token keyword">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x <span class="token operator">*</span> m <span class="token operator">*</span> n<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token keyword">auto</span> g <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">-></span><span class="token keyword">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x <span class="token operator">*</span> m <span class="token operator">*</span> n<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	a <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638617417312.png" alt></p><p>在捕获列表中填入 &amp; 或者 this 即可解决问题<br><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638617435652.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638617534940.png" alt></p><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638617575285.png" alt></p><p>静态函数没有 this 隐含参数，lambda 表达式中当然不能有 this，此时不能访问到实例数据成员，但静态变量是可以随意访问的<br><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/1638617666634.png" alt></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;typeinfo></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		<span class="token keyword">auto</span> L1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>			a<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>		<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="25"></td><td><pre>	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	<span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>		<span class="token keyword">auto</span> L1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">-></span><span class="token keyword">int</span></pre></td></tr><tr><td data-num="31"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>			<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 不能修改静态变量的值</span></pre></td></tr><tr><td data-num="33"></td><td><pre>			d <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>		<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token keyword">int</span> B<span class="token double-colon punctuation">::</span>d <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>	<span class="token class-name">B</span><span class="token double-colon punctuation">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>	cout <span class="token operator">&lt;&lt;</span> B<span class="token double-colon punctuation">::</span>c <span class="token operator">&lt;&lt;</span> <span class="token string">"  "</span> <span class="token operator">&lt;&lt;</span> B<span class="token double-colon punctuation">::</span>d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="偏僻知识"><a class="anchor" href="#偏僻知识">#</a> 偏僻知识</h1><h3 id="引用"><a class="anchor" href="#引用">#</a> 引用</h3><p>右值引用使用的符号是 <code>&amp;&amp;</code> ，如</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 实质上就是将不具名 (匿名) 变量取了个别名</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 编译错误！ 不能将一个左值给赋值一个右值引用</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>A <span class="token function">getTemp</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>A <span class="token operator">&amp;&amp;</span> a <span class="token operator">=</span> <span class="token function">getTemp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//getTemp () 的返回值是右值（临时变量）</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// 此时 a 的值不会因为再调用了其他的函数而改变，说明不是在栈中了，而是另外</span></pre></td></tr></table></figure><p><code>getTemp()</code> 返回的右值本来在表达式语句结束后，其生命也就该终结了（因为是临时变量），而通过右值引用，该右值又重获新生，其生命期将与右值引用类型变量 <code>a</code> 的生命期一样，只要 <code>a</code> 还活着，该右值临时变量将会一直存活下去。实际上就是给那个临时变量取了个名字。</p><p><strong>注意</strong>：这里 <code>a</code> 的<strong>类型</strong>是右值引用类型 ( <code>int &amp;&amp;</code> )，但是如果从左值和右值的角度区分它，它实际上是个<strong>左值</strong>。因为可以对它取地址，而且它还有名字，是一个已经命名的右值。</p><p>所以，左值引用只能绑定左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。但是，<strong>常量左值引用</strong>却是个奇葩，它可以算是一个 “万能” 的引用类型，它可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 常量左值引用绑定右值， 不会报错</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>A <span class="token function">getTemp</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">const</span> A <span class="token operator">&amp;</span> a <span class="token operator">=</span> <span class="token function">getTemp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 不会报错 而 A&amp; a 会报错</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> k<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="/./images/%E5%A4%A7%E7%BA%B2%E7%9F%A5%E8%AF%86/image-20211025230306748.png" alt="./images-20211025230306748"></p><p>完整代码如下</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 常量左值引用绑定 右值， 不会报错</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>A<span class="token operator">&amp;</span> <span class="token function">getTemp</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    A d<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> d<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">return</span> k<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">const</span> A<span class="token operator">&amp;</span> c <span class="token operator">=</span> <span class="token function">getTemp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 不会报错 而 A&amp; a 会报错：无法从 “A” 转换为 “A &amp;”</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d %d %d %d %d \n"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在调用 getTemp 函数和 printf 函数后，栈中的值会发生变化，之后输出的 e 不是 2。但是把这两行代码注释掉之后，就可以正确输出 2 了。说明值都在栈中。</p><div class="tags"><a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C++</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-08-30 10:19:34" itemprop="dateModified" datetime="2022-08-30T10:19:34+08:00">2022-08-30</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="yuan 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="yuan 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="yuan 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>yuan <i class="ic i-at"><em>@</em></i>yuan</li><li class="link"><strong>本文链接：</strong> <a href="https://jyuanhust.github.io/2022/07/22/language/C++/C-%E6%95%99%E7%A8%8B/" title="C++教程">https://jyuanhust.github.io/2022/07/22/language/C++/C-教程/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/07/22/language/python/python%E6%95%99%E7%A8%8B/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;zkz0&#x2F;image&#x2F;raw&#x2F;master&#x2F;img&#x2F;img(92).webp" title="python教程"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 编程语言</span><h3>python教程</h3></a></div><div class="item right"><a href="/2022/07/24/backend/django/django/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;zkz0&#x2F;image&#x2F;raw&#x2F;master&#x2F;img&#x2F;img(96).webp" title="初识django"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> django</span><h3>初识django</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D"><span class="toc-number">1.</span> <span class="toc-text">单词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%80%BC%E5%9F%9F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">预定义类型及值域和常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.</span> <span class="toc-text">一些关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr"><span class="toc-number">3.1.</span> <span class="toc-text">constexpr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">常量表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">constexpr 修饰普通变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.3.</span> <span class="toc-text">constexpr 修饰函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%A5%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E5%8D%B3%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E6%98%AF-void"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">该函数必须有返回值，即函数的返回值类型不能是 void。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%89%8D%E5%BF%85%E9%A1%BB%E6%9C%89%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">函数在使用之前，必须有对应的定义语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#return-%E8%BF%94%E5%9B%9E%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E9%A1%BB%E6%98%AF%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">return 返回的表达式必须是常量表达式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E5%92%8Cconstexpr%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.1.4.</span> <span class="toc-text">const 和 constexpr 的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">2.3 变量及其类型解析</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E8%AF%AD%E5%8F%A5-%E5%87%BD%E6%95%B0%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number"></span> <span class="toc-text">第 3 章 语句、函数及程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#32"><span class="toc-number">1.</span> <span class="toc-text">3.2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">constexpr 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.</span> <span class="toc-text">3.3 作用域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">第 4 章 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">4.1 类的声明和定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%8F%8A%E7%AA%81%E7%A0%B4%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">4.2 成员访问权限及突破方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E5%86%85%E8%81%94-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%8F%8A%E4%BD%8D%E6%AE%B5"><span class="toc-number">3.</span> <span class="toc-text">4.3 内联、匿名类及位段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">4.4 new 和 delete 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E9%9A%90%E5%90%AB%E5%8F%82%E6%95%B0this"><span class="toc-number">5.</span> <span class="toc-text">4.5 隐含参数 this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">4.6 对象的构造与析构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%88%90%E5%91%98%E5%8F%8A%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="toc-number"></span> <span class="toc-text">第 5 章 成员及成员指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="toc-number">1.</span> <span class="toc-text">5.1 实例成员指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-const-volatile%E5%92%8Cmutable"><span class="toc-number">2.</span> <span class="toc-text">5.2 const、volatile 和 mutable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">3.</span> <span class="toc-text">5.3 静态数据成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98"><span class="toc-number">4.</span> <span class="toc-text">5.4 静态函数成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="toc-number">5.</span> <span class="toc-text">5.5 静态成员指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="toc-number"></span> <span class="toc-text">第 6 章 继承与构造</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E5%8D%95%E7%BB%A7%E6%89%BF%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">6.1 单继承类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">6.2 继承方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE"><span class="toc-number">3.</span> <span class="toc-text">6.3 成员访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">6.4 构造与析构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E7%88%B6%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">6.5 父类和子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">6.</span> <span class="toc-text">6.6 派生类的内存布局</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">第 7 章 可访问性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.</span> <span class="toc-text">7.1 作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4"><span class="toc-number">2.</span> <span class="toc-text">7.2 名字空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E6%88%90%E5%91%98%E5%8F%8B%E5%85%83"><span class="toc-number">3.</span> <span class="toc-text">7.3 成员友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%99%AE%E9%80%9A%E5%8F%8B%E5%85%83%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.</span> <span class="toc-text">7.4 普通友元及其注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">第 8 章 多态与虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">8.1 虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">8.2 虚析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">8.3 类的引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">8.4 抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85-%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%8B%E5%85%83%E4%B8%8E%E6%99%9A%E6%9C%9F%E7%BB%91%E5%AE%9A"><span class="toc-number">5.</span> <span class="toc-text">8.5 虚函数友元与晚期绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">6.</span> <span class="toc-text">8.6 有虚函数时的内存布局</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">第 9 章 多继承与虚基类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91-%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">9.1 多继承类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0"><span class="toc-number"></span> <span class="toc-text">第 10 章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">10.1 异常处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number"></span> <span class="toc-text">第 11 章 运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">11.1 运算符概述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90-%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%8E%A8%E5%AF%BC"><span class="toc-number"></span> <span class="toc-text">第 12 章 类型解析、转换与推导</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E9%9A%90%E5%BC%8F%E4%B8%8E%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.</span> <span class="toc-text">12.1 隐式与显式类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#123-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">12.3 类型转换实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">3.</span> <span class="toc-text">12.4 自动类型推导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#125-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">12.5 Lambda 表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%81%8F%E5%83%BB%E7%9F%A5%E8%AF%86"><span class="toc-number"></span> <span class="toc-text">偏僻知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">0.1.</span> <span class="toc-text">引用</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/07/22/language/python/python%E6%95%99%E7%A8%8B/" rel="bookmark" title="python教程">python教程</a></li><li class="active"><a href="/2022/07/22/language/C++/C-%E6%95%99%E7%A8%8B/" rel="bookmark" title="C++教程">C++教程</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="yuan" data-src="/images/avatar.jpg"><p class="name" itemprop="name">yuan</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">429</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">72</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">61</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item email" data-url="bWFpbHRvOjIwODM2MzU1MjVAcXEuY29t" title="mailto:2083635525@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/07/22/language/python/python%E6%95%99%E7%A8%8B/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/07/24/backend/django/django/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2023/06/25/computer-science/%E6%AF%94%E8%B5%9B/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E6%AF%94%E8%B5%9B%E7%AD%94%E6%A1%88%E4%BB%A3%E7%A0%81/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/06/24/frontend/javascript/JavaScript%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/06/24/language/python/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ai/" title="分类于 ai">ai</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="分类于 pytorch深度学习">pytorch深度学习</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/chapter-natural-language-processing-applications/" title="分类于 chapter_natural-language-processing-applications">chapter_natural-language-processing-applications</a></div><span><a href="/2023/02/15/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/chapter_natural-language-processing-applications/sentiment-analysis-rnn/" title="sentiment-analysis-rnn">sentiment-analysis-rnn</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ai/" title="分类于 ai">ai</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="分类于 pytorch深度学习">pytorch深度学习</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/chapter-convolutional-modern/" title="分类于 chapter_convolutional-modern">chapter_convolutional-modern</a></div><span><a href="/2023/02/15/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/chapter_convolutional-modern/vgg/" title="vgg">vgg</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ai/" title="分类于 ai">ai</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="分类于 pytorch深度学习">pytorch深度学习</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/chapter-recurrent-modern/" title="分类于 chapter_recurrent-modern">chapter_recurrent-modern</a></div><span><a href="/2023/02/15/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/chapter_recurrent-modern/lstm/" title="lstm">lstm</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/backend/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/backend/django/" title="分类于 django">django</a></div><span><a href="/2022/09/13/backend/django/%E5%9C%A8app%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8Btests%E6%A8%A1%E5%9D%97%E4%B8%AD%E6%B5%8B%E8%AF%95/" title="在app文件夹下tests模块中测试">在app文件夹下tests模块中测试</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ai/" title="分类于 ai">ai</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="分类于 pytorch深度学习">pytorch深度学习</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/chapter-preliminaries/" title="分类于 chapter_preliminaries">chapter_preliminaries</a></div><span><a href="/2023/02/15/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/chapter_preliminaries/pandas/" title="pandas">pandas</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ai/" title="分类于 ai">ai</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="分类于 pytorch深度学习">pytorch深度学习</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/chapter-recurrent-modern/" title="分类于 chapter_recurrent-modern">chapter_recurrent-modern</a></div><span><a href="/2023/02/15/ai/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/chapter_recurrent-modern/bi-rnn/" title="bi-rnn">bi-rnn</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 computer-science">computer-science</a></div><span><a href="/2023/03/03/frontend/blog/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" title="博客搭建教程">博客搭建教程</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">yuan @ Mi Manchi</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">2.9m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">44:38</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/07/22/language/C++/C-教程/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>