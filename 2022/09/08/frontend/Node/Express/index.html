<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="yuan" href="https://huang-junyuan.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="yuan" href="https://huang-junyuan.github.io/atom.xml"><link rel="alternate" type="application/json" title="yuan" href="https://huang-junyuan.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Node.js"><link rel="canonical" href="https://huang-junyuan.github.io/2022/09/08/frontend/Node/Express/"><title>Express - Node.js - 前端 | Mi Manchi = yuan = Whatever is worth doing at all is worth doing well</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Express</h1><div class="meta"><span class="item" title="创建时间：2022-09-08 11:40:52"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-09-08T11:40:52+08:00">2022-09-08</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.7k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Mi Manchi</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclfw2t96j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclil3m4ej20zk0m8tn8.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciuv0socj20zk0m8qes.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipex2cdtbj20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipewf5l51j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciusoyjnj219g0u0x56.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/frontend/" itemprop="item" rel="index" title="分类于 前端"><span itemprop="name">前端</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/frontend/Node-js/" itemprop="item" rel="index" title="分类于 Node.js"><span itemprop="name">Node.js</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://huang-junyuan.github.io/2022/09/08/frontend/Node/Express/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="yuan"><meta itemprop="description" content="Whatever is worth doing at all is worth doing well, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="yuan"></span><div class="body md" itemprop="articleBody"><h2 id="初识-express"><a class="anchor" href="#初识-express">#</a> 初识 Express</h2><p>Express 简介</p><ol><li>什么是 Express</li></ol><p>官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。<br>通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。<br>Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。</p><p>Express 的中文官网： <span class="exturl" data-url="aHR0cDovL3d3dy5leHByZXNzanMuY29tLmNuLw==">http://www.expressjs.com.cn/</span></p><ol start="2"><li>进一步理解 Express</li></ol><p>思考：不使用 Express 能否创建 Web 服务器？<br>答案：能，使用 Node.js 提供的原生 http 模块即可。</p><p>思考：既生瑜何生亮（有了 http 内置模块，为什么还有用 Express）？<br>答案：http 内置模块用起来很复杂，开发效率低；Express 是基于内置的 http 模块进一步封装出来的，能够极大的提高开发效率。</p><p>思考：http 内置模块与 Express 是什么关系？<br>答案：类似于浏览器中 Web API 和 jQuery 的关系。后者是基于前者进一步封装出来的。</p><ol start="3"><li>Express 能做什么</li></ol><p>对于前端程序员来说，最常见的两种服务器，分别是：<br>	Web 网站服务器：专门对外提供 Web 网页资源的服务器。<br>	API 接口服务器：专门对外提供 API 接口的服务器。<br>使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。</p><p>1.2	Express 的基本使用</p><ol><li>安装</li></ol><p>在项目所处的目录中，运行如下的终端命令，即可将 express 安装到项目中使用：</p><p><img data-src="/./images/Express/1662604061585.png" alt="1662604061585"></p><ol start="2"><li>创建基本的 Web 服务器</li></ol><p><img data-src="/./images/Express/1662604079754.png" alt="1662604079754"></p><ol start="3"><li>监听 GET 请求</li></ol><p>通过 app.get () 方法，可以监听客户端的 GET 请求，具体的语法格式如下：</p><p><img data-src="/./images/Express/1662604135973.png" alt="1662604135973"></p><ol start="4"><li>监听 POST 请求</li></ol><p>通过 app.post () 方法，可以监听客户端的 POST 请求，具体的语法格式如下：</p><p><img data-src="/./images/Express/1662604225540.png" alt="1662604225540"></p><ol start="5"><li>把内容响应给客户端</li></ol><p>通过 res.send () 方法，可以把处理好的内容，发送给客户端：</p><p><img data-src="/./images/Express/1662604264199.png" alt="1662604264199"></p><ol start="6"><li>获取 URL 中携带的查询参数</li></ol><p>通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：</p><p><img data-src="/./images/Express/1662604314284.png" alt="1662604314284"></p><ol start="7"><li>获取 URL 中的动态参数</li></ol><p>通过 req.params 对象，可以访问到 URL 中，通过：匹配到的动态参数：</p><p><img data-src="/./images/Express/1662604398071.png" alt="1662604398071"></p><p>1.3	托管静态资源</p><ol><li>express.static()</li></ol><p>express 提供了一个非常好用的函数，叫做 express.static ()，通过它，我们可以非常方便地创建一个静态资源服务器，例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：</p><p><img data-src="/./images/Express/1662604417828.png" alt="1662604417828"></p><p>现在，你就可以访问 public 目录中的所有文件了：<br><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL2ltYWdlcy9iZy5qcGc=">http://localhost:3000/images/bg.jpg</span></p><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL2Nzcy9zdHlsZS5jc3M=">http://localhost:3000/css/style.css</span><br><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL2pzL2xvZ2luLmpz">http://localhost:3000/js/login.js</span></p><p>注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在 URL 中。</p><ol start="2"><li>托管多个静态资源目录</li></ol><p>如果要托管多个静态资源目录，请多次调用 express.static () 函数：</p><p><img data-src="/./images/Express/1662604466033.png" alt="1662604466033"></p><p>访问静态资源文件时，express.static () 函数会根据目录的添加顺序查找所需的文件。</p><ol start="3"><li>挂载路径前缀</li></ol><p>如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：</p><p><img data-src="/./images/Express/1662604511614.png" alt="1662604511614"></p><p>现在，你就可以通过带有 /public 前缀地址来访问 public 目录中的文件了： <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3B1YmxpYy9pbWFnZXMva2l0dGVuLmpwZw==">http://localhost:3000/public/images/kitten.jpg</span> <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3B1YmxpYy9jc3Mvc3R5bGUuY3Nz">http://localhost:3000/public/css/style.css</span> <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDozMDAwL3B1YmxpYy9qcy9hcHAuanM=">http://localhost:3000/public/js/app.js</span></p><p>1.4	nodemon</p><ol><li>为什么要使用 nodemon</li></ol><p>在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。<br>现在，我们可以使用 nodemon（<span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvbm9kZW1vbiVFRiVCQyU4OQ==">https://www.npmjs.com/package/nodemon）</span> 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。</p><ol start="2"><li>安装 nodemon</li></ol><p>在终端中，运行如下命令，即可将 nodemon 安装为全局可用的工具：</p><p><img data-src="/./images/Express/1662604559874.png" alt="1662604559874"></p><ol start="3"><li>使用 nodemon</li></ol><p>当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 node app.js 命令，来启动项目。这样做的坏处是：代码被修改之后，需要手动重启项目。<br>现在，我们可以将 node 命令替换为 nodemon 命令，使用 nodemon app.js 来启动项目。这样做的好处是：代码被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果。</p><p><img data-src="/./images/Express/1662604581220.png" alt="1662604581220"></p><h2 id="express-路由"><a class="anchor" href="#express-路由">#</a> Express 路由</h2><p>2.1 路由的概念</p><ol><li>什么是路由</li></ol><p>广义上来讲，路由就是映射关系。</p><p>在这里，路由是按键与服务之间的映射关系</p><ol start="3"><li>Express 中的路由</li></ol><p>在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。<br>Express 中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数，格式如下：</p><p><img data-src="/./images/Express/1662604787411.png" alt="1662604787411"></p><ol start="4"><li>Express 中的路由的例子</li></ol><p><img data-src="/./images/Express/1662604808894.png" alt="1662604808894"></p><ol start="5"><li>路由的匹配过程</li></ol><p>每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。<br>在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理。</p><p><img data-src="/./images/Express/1662604933872.png" alt="1662604933872"></p><p>路由匹配的注意点：<br>① 按照定义的先后顺序进行匹配<br>② 请求类型和请求的 URL 同时匹配成功，才会调用对应的处理函数</p><ol><li>最简单的用法</li></ol><p>在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下：</p><p><img data-src="/./images/Express/1662604978498.png" alt="1662604978498"></p><ol start="2"><li>模块化路由</li></ol><p>为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下：<br>① 创建路由模块对应的 .js 文件<br>② 调用 express.Router () 函数创建路由对象<br>③ 向路由对象上挂载具体的路由<br>④ 使用 module.exports 向外共享路由对象<br>⑤ 使用 app.use () 函数注册路由模块</p><ol start="3"><li>创建路由模块</li></ol><p><img data-src="/./images/Express/1662605591622.png" alt="1662605591622"></p><ol start="4"><li>注册路由模块</li></ol><p><img data-src="/./images/Express/1662605624293.png" alt="1662605624293"></p><ol start="5"><li>为路由模块添加前缀</li></ol><p>类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单：</p><p><img data-src="/./images/Express/1662605667159.png" alt="1662605667159"></p><h2 id="express-中间件"><a class="anchor" href="#express-中间件">#</a> Express 中间件</h2><p>3.1 中间件的概念</p><ol><li>什么是中间件</li></ol><p>中间件（Middleware ），特指业务流程的中间处理环节。</p><ol start="3"><li>Express 中间件的调用流程</li></ol><p>当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。</p><p><img data-src="/./images/Express/1662605731406.png" alt="1662605731406"></p><ol start="4"><li>Express 中间件的格式</li></ol><p>Express 的中间件，本质上就是一个 function 处理函数，Express 中间件的格式如下：</p><p><img data-src="/./images/Express/1662605758287.png" alt="1662605758287"></p><p>注意：中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中只包含 req 和 res。</p><ol start="5"><li>next 函数的作用</li></ol><p>next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。</p><p><img data-src="/./images/Express/1662605817810.png" alt="1662605817810"></p><p>3.2	Express 中间件的初体验</p><ol><li>定义中间件函数</li></ol><p>可以通过如下的方式，定义一个最简单的中间件函数：</p><p><img data-src="/./images/Express/1662605844063.png" alt="1662605844063"></p><ol start="2"><li>全局生效的中间件</li></ol><p>客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件。通过调用 app.use (中间件函数)，即可定义一个全局生效的中间件，示例代码如下：</p><p><img data-src="/./images/Express/1662605874910.png" alt="1662605874910"></p><ol start="3"><li>定义全局中间件的简化形式</li></ol><p><img data-src="/./images/Express/1662605898524.png" alt="1662605898524"></p><ol start="4"><li>中间件的作用</li></ol><p>多个中间件之间，共享同一份 req 和 res。基于这样的特性，我们可以在上游的中间件中，统一为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。</p><p><img data-src="/./images/Express/1662605944582.png" alt="1662605944582"></p><ol start="5"><li>定义多个全局中间件</li></ol><p>可以使用 app.use () 连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用，示例代码如下：</p><p><img data-src="/./images/Express/1662605968776.png" alt="1662605968776"></p><ol start="6"><li>局部生效的中间件</li></ol><p>不使用 app.use () 定义的中间件，叫做局部生效的中间件，示例代码如下：</p><p><img data-src="/./images/Express/1662606066259.png" alt="1662606066259"></p><ol start="7"><li>定义多个局部中间件</li></ol><p>可以在路由中，通过如下两种等价的方式，使用多个局部中间件：</p><p><img data-src="/./images/Express/1662606128542.png" alt="1662606128542"></p><ol start="8"><li>了解中间件的 5 个使用注意事项</li></ol><p>① 一定要在路由之前注册中间件<br>② 客户端发送过来的请求，可以连续调用多个中间件进行处理<br>③ 执行完中间件的业务代码之后，不要忘记调用 next () 函数<br>④ 为了防止代码逻辑混乱，调用 next () 函数后不要再写额外的代码<br>⑤ 连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象</p><p>3.3	中间件的分类<br>为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类，分别是：<br>①	应用级别的中间件<br>②	路由级别的中间件<br>③	错误级别的中间件<br>④	Express 内置的中间件<br>⑤	第三方的中间件</p><ol><li>应用级别的中间件</li></ol><p>通过 app.use () 或 app.get () 或 app.post () ，绑定到 app 实例上的中间件，叫做应用级别的中间件，代码示例如下：</p><p><img data-src="/./images/Express/1662606210717.png" alt="1662606210717"></p><ol start="2"><li>路由级别的中间件</li></ol><p>绑定到 express.Router () 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过，应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上，代码示例如下：</p><p><img data-src="/./images/Express/1662606275055.png" alt="1662606275055"></p><ol start="3"><li>错误级别的中间件</li></ol><p>错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。<br>格式：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 (err, req, res, next)。</p><p><img data-src="/./images/Express/1662606308139.png" alt="1662606308139"></p><p>注意：错误级别的中间件，必须注册在所有路由之后！</p><p>错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 (err, req, res, next)。</p><p><img data-src="/./images/Express/1662606350425.png" alt="1662606350425"></p><p>注意：错误级别的中间件，必须注册在所有路由之后！</p><ol start="4"><li>Express 内置的中间件</li></ol><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：<br>①	express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）<br>②	express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）<br>③	express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</p><p><img data-src="/./images/Express/1662606381634.png" alt="1662606381634"></p><ol start="5"><li>第三方的中间件</li></ol><p>非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率。<br>例如：在 express@4.16.0 之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步骤如下：<br>① 运行 npm install body-parser 安装中间件<br>② 使用 require 导入中间件<br>③ 调用 app.use () 注册并使用中间件</p><p>注意：Express 内置的 express.urlencoded 中间件，就是基于 body-parser 这个第三方中间件进一步封装出来的。</p><p>3.4	自定义中间件</p><ol><li>需求描述与实现步骤</li></ol><p>自己手动模拟一个类似于 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据。实现步骤：<br>① 定义中间件<br>② 监听 req 的 data 事件<br>③ 监听 req 的 end 事件<br>④ 使用 querystring 模块解析请求体数据<br>⑤ 将解析出来的数据对象挂载为 req.body<br>⑥ 将自定义中间件封装为模块</p><ol start="2"><li>定义中间件</li></ol><p>使用 app.use () 来定义全局生效的中间件，代码如下：</p><p><img data-src="/./images/Express/1662606435471.png" alt="1662606435471"></p><ol start="3"><li>监听 req 的 data 事件</li></ol><p>在中间件中，需要监听 req 对象的 data 事件，来获取客户端发送到服务器的数据。<br>如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以 data 事件可能会触发多次，每一次触发 data 事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。</p><ol start="4"><li>监听 req 的 end 事件</li></ol><p>当请求体数据接收完毕之后，会自动触发 req 的 end 事件。<br>因此，我们可以在 req 的 end 事件中，拿到并处理完整的请求体数据。示例代码如下：</p><p><img data-src="/./images/Express/1662606510565.png" alt="1662606510565"></p><ol start="5"><li>使用 querystring 模块解析请求体数据</li></ol><p>Node.js 内置了一个 querystring 模块，专门用来处理查询字符串。通过这个模块提供的 parse () 函数，可以轻松把查询字符串，解析成对象的格式。示例代码如下：</p><p><img data-src="/./images/Express/1662606551772.png" alt="1662606551772"></p><ol start="6"><li>将解析出来的数据对象挂载为 req.body</li></ol><p>上游的中间件和下游的中间件及路由之间，共享同一份 req 和 res。因此，我们可以将解析出来的数据，挂载为 req<br>的自定义属性，命名为 req.body，供下游使用。示例代码如下：</p><p><img data-src="/./images/Express/1662606595804.png" alt="1662606595804"></p><ol start="7"><li>将自定义中间件封装为模块</li></ol><p>为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下：</p><p><img data-src="/./images/Express/1662606620999.png" alt="1662606620999"></p><h2 id="使用-express-写接口"><a class="anchor" href="#使用-express-写接口">#</a> 使用 Express 写接口</h2><p>4.1	创建基本的服务器</p><p><img data-src="/./images/Express/1662606718626.png" alt="1662606718626"></p><p>4.2	创建 API 路由模块</p><p><img data-src="/./images/Express/1662607403073.png" alt="1662607403073"></p><p>4.3	编写 GET 接口</p><p><img data-src="/./images/Express/1662607505436.png" alt="1662607505436"></p><p>4.4	编写 POST 接口</p><p><img data-src="/./images/Express/1662607605962.png" alt="1662607605962"></p><p>注意：如果要获取 URL-encoded 格式的请求体数据，必须配置中间件 app.use (express.urlencoded ({ extended: false}))</p><p>4.5	CORS 跨域资源共享</p><ol><li>接口的跨域问题</li></ol><p>刚才编写的 GET 和 POST 接口，存在一个很严重的问题：不支持跨域请求。解决接口跨域问题的方案主要有两种：<br>①	CORS（主流的解决方案，推荐使用）<br>②	JSONP（有缺陷的解决方案：只支持 GET 请求）</p><ol start="2"><li>使用 cors 中间件解决跨域问题</li></ol><p>cors 是 Express 的一个第三方中间件。通过安装和配置 cors 中间件，可以很方便地解决跨域问题。使用步骤分为如下 3 步：<br>① 运行 npm install cors 安装中间件<br>② 使用 const cors = require ('cors') 导入中间件<br>③ 在路由之前调用 app.use (cors ()) 配置中间件</p><ol start="3"><li>什么是 CORS</li></ol><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，这些 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源。<br>浏览器的同源安全策略默认会阻止网页 “跨域” 获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可以解除浏览器端的跨域访问限制。</p><p><img data-src="/./images/Express/1662607676704.png" alt="1662607676704"></p><ol start="4"><li>CORS 的注意事项</li></ol><p>① CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。<br>② CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</p><ol start="5"><li>CORS 响应头部 - Access-Control-Allow-Origin</li></ol><p>响应头部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下:</p><p><img data-src="/./images/Express/1662607716697.png" alt="1662607716697"></p><p>其中，origin 参数的值指定了允许访问该资源的外域 URL。例如，下面的字段值将只允许来自 <span class="exturl" data-url="aHR0cDovL2l0Y2FzdC5jbg==">http://itcast.cn</span> 的请求：</p><p><img data-src="/./images/Express/1662607731675.png" alt="1662607731675"></p><ol start="5"><li>CORS 响应头部 - Access-Control-Allow-Origin</li></ol><p>如果指定了 Access-Control-Allow-Origin 字段的值为通配符 *，表示允许来自任何域的请求，示例代码如下：</p><p><img data-src="/./images/Express/1662607754295.png" alt="1662607754295"></p><ol start="6"><li>CORS 响应头部 - Access-Control-Allow-Headers</li></ol><p>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：<br>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、<br>Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）<br>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！</p><p><img data-src="/./images/Express/1662607775855.png" alt="1662607775855"></p><ol start="7"><li>CORS 响应头部 - Access-Control-Allow-Methods</li></ol><p>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。<br>如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods<br>来指明实际请求所允许使用的 HTTP 方法。示例代码如下：</p><p><img data-src="/./images/Express/1662607795573.png" alt="1662607795573"></p><ol start="8"><li>CORS 请求的分类</li></ol><p>客户端在请求 CORS 接口时，根据请求方式和请求头的不同，可以将 CORS 的请求分为两大类，分别是：<br>① 简单请求<br>② 预检请求</p><ol start="9"><li>简单请求</li></ol><p>同时满足以下两大条件的请求，就属于简单请求：<br>①	请求方式：GET、POST、HEAD 三者之一<br>② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、 Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application/x-www-form- urlencoded、multipart/form-data、text/plain）</p><ol start="10"><li>预检请求</li></ol><p>只要符合以下任何一个条件的请求，都需要进行预检请求：<br>①	请求方式为 GET、POST、HEAD 之外的请求 Method 类型<br>②	请求头中包含自定义头部字段<br>③	向服务器发送了 application/json 格式的数据</p><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为 “预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</p><ol start="11"><li>简单请求和预检请求的区别</li></ol><p>简单请求的特点：客户端与服务器之间只会发生一次请求。<br>预检请求的特点：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。</p><p>4.6	JSONP 接口</p><ol><li>回顾 JSONP 的概念与特点</li></ol><p>概念：浏览器端通过 &lt;script&gt; 标签的 src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做 JSONP。<br>特点：<br>① JSONP 不属于真正的 Ajax 请求，因为它没有使用 XMLHttpRequest 这个对象。<br>② JSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求。</p><p>JSONP 接口</p><ol start="2"><li>创建 JSONP 接口的注意事项</li></ol><p>如果项目中已经配置了 CORS 跨域资源共享，为了防止冲突，必须在配置 CORS 中间件之前声明 JSONP 的接口。否则<br>JSONP 接口会被处理成开启了 CORS 的接口。示例代码如下：</p><p><img data-src="/./images/Express/1662607874887.png" alt="1662607874887"></p><ol start="3"><li>实现 JSONP 接口的步骤</li></ol><p>① 获取客户端发送过来的回调函数的名字<br>② 得到要通过 JSONP 形式发送给客户端的数据<br>③ 根据前两步得到的数据，拼接出一个函数调用的字符串<br>④ 把上一步拼接得到的字符串，响应给客户端的 &lt;script&gt; 标签进行解析执行</p><ol start="4"><li>实现 JSONP 接口的具体代码</li></ol><p><img data-src="/./images/Express/1662607906746.png" alt="1662607906746"></p><ol start="5"><li>在网页中使用 jQuery 发起 JSONP 请求</li></ol><p>调用 $.ajax () 函数，提供 JSONP 的配置选项，从而发起 JSONP 请求，示例代码如下：</p><p><img data-src="/./images/Express/1662607927667.png" alt="1662607927667"></p><div class="tags"><a href="/tags/Node-js/" rel="tag"><i class="ic i-tag"></i> Node.js</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-09-11 17:21:15" itemprop="dateModified" datetime="2022-09-11T17:21:15+08:00">2022-09-11</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="yuan 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="yuan 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="yuan 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>yuan <i class="ic i-at"><em>@</em></i>yuan</li><li class="link"><strong>本文链接：</strong> <a href="https://huang-junyuan.github.io/2022/09/08/frontend/Node/Express/" title="Express">https://huang-junyuan.github.io/2022/09/08/frontend/Node/Express/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/09/08/frontend/Node/Node%E6%A8%A1%E5%9D%97%E5%8C%96/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclga70tsj20zk0m84mr.jpg" title="Node模块化"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Node.js</span><h3>Node模块化</h3></a></div><div class="item right"><a href="/2022/09/08/frontend/CSS/CSS%E5%B8%83%E5%B1%80/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclxfdlttj20zk0m8npd.jpg" title="CSS布局"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 前端</span><h3>CSS布局</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86-express"><span class="toc-number">1.</span> <span class="toc-text">初识 Express</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#express-%E8%B7%AF%E7%94%B1"><span class="toc-number">2.</span> <span class="toc-text">Express 路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#express-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">Express 中间件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-express-%E5%86%99%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.</span> <span class="toc-text">使用 Express 写接口</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/09/08/frontend/Node/Express/" rel="bookmark" title="Express">Express</a></li><li><a href="/2022/09/08/frontend/Node/Node%E6%A8%A1%E5%9D%97%E5%8C%96/" rel="bookmark" title="Node模块化">Node模块化</a></li><li><a href="/2022/09/08/frontend/Node/%E5%88%9D%E8%AF%86Node%E5%8F%8A%E5%85%B6%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/" rel="bookmark" title="初识Node及其内置模块">初识Node及其内置模块</a></li><li><a href="/2022/09/08/frontend/Node/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/" rel="bookmark" title="数据库与身份认证">数据库与身份认证</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="yuan" data-src="/images/avatar.jpg"><p class="name" itemprop="name">yuan</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">187</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">40</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">37</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item email" data-url="bWFpbHRvOjIwODM2MzU1MjVAcXEuY29t" title="mailto:2083635525@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/09/08/frontend/Node/Node%E6%A8%A1%E5%9D%97%E5%8C%96/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/09/08/frontend/CSS/CSS%E5%B8%83%E5%B1%80/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/ai/" title="分类于 ai">ai</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch/" title="分类于 pytorch">pytorch</a></div><span><a href="/2022/07/25/ai/pytorch/%E4%BD%BF%E7%94%A8Pytorch%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/" title="使用Pytorch实现手写数字识别">使用Pytorch实现手写数字识别</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/tools/" title="分类于 tools">tools</a> <i class="ic i-angle-right"></i> <a href="/categories/tools/%E7%88%AC%E8%99%AB/" title="分类于 爬虫">爬虫</a></div><span><a href="/2022/09/09/tools/%E7%88%AC%E8%99%AB/selenium/" title="selenium">selenium</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/tools/" title="分类于 tools">tools</a></div><span><a href="/2022/07/26/tools/csdn%E5%8D%9A%E5%AE%A2%E5%AF%BC%E5%87%BA%E4%B8%BAmd/" title="csdn博客导出为md">csdn博客导出为md</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7/" title="分类于 工具">工具</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%B7%A5%E5%85%B7/%E7%88%AC%E8%99%AB/" title="分类于 爬虫">爬虫</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%B7%A5%E5%85%B7/%E7%88%AC%E8%99%AB/ai/" title="分类于 ai">ai</a></div><span><a href="/2022/08/26/language/python/pandas%E7%94%A8%E6%B3%95/" title="pandas用法">pandas用法</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/10/25/computer-science/base/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%AE%9E%E8%B7%B5MySQL/%E5%AE%9E%E8%AE%AD1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E4%B8%8E%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%AE%9A%E4%B9%89Create/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ai/" title="分类于 ai">ai</a> <i class="ic i-angle-right"></i> <a href="/categories/ai/pytorch/" title="分类于 pytorch">pytorch</a></div><span><a href="/2022/08/24/ai/pytorch/Pytorch%E7%9A%84data-norm%EF%BC%88%E5%87%A0%E7%A7%8D%E8%8C%83%E6%95%B0-norm-%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%EF%BC%89/" title="Pytorch的data.norm（几种范数(norm)的详细介绍）">Pytorch的data.norm（几种范数(norm)的详细介绍）</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/09/28/computer-science/base/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 computer-science">computer-science</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="分类于 计算机组成原理">计算机组成原理</a></div><span><a href="/2022/08/24/computer-science/base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="计算机系统概述">计算机系统概述</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/07/22/backend/java/Java%E6%95%99%E7%A8%8B/" title="Java教程">Java教程</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/10/23/%E8%AF%BE%E5%A4%96/RoboMaster/%E5%93%A8%E5%B2%97/%E7%AC%94%E8%AE%B0/" title="未命名">未命名</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">yuan @ Mi Manchi</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.1m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">16:30</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/09/08/frontend/Node/Express/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>